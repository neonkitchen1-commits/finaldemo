<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>NeuroScent - Core Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500&family=Inter:wght@300;400;500;600&family=Noto+Sans+SC:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #f5f5f0;
            --fg: #2a2a2a;
            --gray: #e0e0e0;
            --accent: #c02625;
            --green-hit: #00cc00;
            --red-miss: #dd0000;
        }
        
        :root[data-theme="dark"] {
            --bg: #1a1a1a;
            --fg: #e8e8e8;
            --gray: #3a3a3a;
            --accent: #ff4444;
            --green-hit: #00ff00;
            --red-miss: #ff3333;
        }
        
        body { 
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--fg);
            overflow: hidden;
            cursor: none;
            -webkit-font-smoothing: antialiased;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(42, 42, 42, 0.01) 2px, rgba(42, 42, 42, 0.01) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(42, 42, 42, 0.01) 2px, rgba(42, 42, 42, 0.01) 4px);
            pointer-events: none;
            z-index: 1;
            mix-blend-mode: multiply;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 40%, rgba(255, 255, 255, 0.5) 0%, transparent 50%),
                        radial-gradient(circle at 70% 60%, rgba(42, 42, 42, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: breathe 8s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.8; }
        }
        
        @media (pointer: coarse) {
            body { cursor: auto; }
            #cursor { display: none; }
        }
        
        .serif { font-family: 'EB Garamond', serif; }
        .zh { font-family: 'Noto Sans SC', sans-serif; font-weight: 300; }
        
        #cursor {
            width: 10px;
            height: 10px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9), rgba(42, 42, 42, 0.85));
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.2s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.2s;
            box-shadow: 
                0 0 8px rgba(42, 42, 42, 0.4),
                0 0 20px rgba(42, 42, 42, 0.2),
                inset 0 0 4px rgba(255, 255, 255, 0.3);
            opacity: 0.95;
            border: 1.5px solid rgba(255, 255, 255, 0.6);
            mix-blend-mode: normal;
        }
        
        :root[data-theme="dark"] #cursor {
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.95), rgba(230, 230, 230, 0.9));
            box-shadow: 
                0 0 10px rgba(255, 255, 255, 0.5),
                0 0 24px rgba(255, 255, 255, 0.3),
                inset 0 0 4px rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        #cursor.active { 
            transform: scale(2.8); 
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.95), rgba(42, 42, 42, 0.9));
            box-shadow: 
                0 0 12px rgba(42, 42, 42, 0.6),
                0 0 24px rgba(42, 42, 42, 0.3),
                inset 0 0 6px rgba(255, 255, 255, 0.4);
        }
        
        :root[data-theme="dark"] #cursor.active {
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 1), rgba(240, 240, 240, 0.95));
            box-shadow: 
                0 0 14px rgba(255, 255, 255, 0.7),
                0 0 28px rgba(255, 255, 255, 0.4),
                inset 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: filter 0.5s ease;
        }
        
        #canvas3d.bloom {
            filter: blur(2px) brightness(1.3);
        }
        
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }
        #ui-layer > * { 
            pointer-events: auto; /* But enable pointer events for direct children */
        }
        
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.6s ease, visibility 0.6s;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            pointer-events: none;
        }
        .screen.active { 
            opacity: 1; 
            visibility: visible;
            pointer-events: auto;
            z-index: 10;
        }
        
        #lang-switch {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            display: flex;
            gap: 0;
            background: transparent;
            border: 1px solid rgba(42, 42, 42, 0.15);
            overflow: hidden;
        }
        
        @media (max-width: 768px) {
            #lang-switch {
                top: 0.75rem;
                right: 0.75rem;
            }
        }
        
        .lang-btn {
            background: rgba(255, 255, 255, 0.92);
            border: none;
            border-right: 1px solid rgba(42, 42, 42, 0.1);
            color: var(--fg);
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.6rem;
            letter-spacing: 0.15em;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            font-weight: 400;
        }
        
        .lang-btn:last-child {
            border-right: none;
        }
        
        .lang-btn.active {
            background: var(--fg);
            color: var(--bg);
        }
        
        .lang-btn:hover:not(.active) {
            background: rgba(42, 42, 42, 0.05);
        }
        
        
        #welcome-screen {
            flex-direction: column;
            padding: 2rem 1rem;
            pointer-events: auto;
        }
        
        .welcome-logo {
            font-size: clamp(2.5rem, 12vw, 8rem);
            font-weight: 400;
            letter-spacing: 0.08em;
            color: var(--fg);
            margin-bottom: 0.5rem;
            line-height: 0.92;
            text-shadow: none;
            position: relative;
            mix-blend-mode: multiply;
        }
        
        /* Line intentionally removed - Wabi-sabi aesthetic: imperfection as beauty */
        
        .welcome-subtitle {
            font-size: clamp(0.65rem, 1.5vw, 0.8rem);
            color: rgba(42, 42, 42, 0.45);
            letter-spacing: 0.25em;
            margin-bottom: 3rem;
            text-transform: uppercase;
            font-weight: 300;
            text-align: center;
            border-top: 1px solid rgba(42, 42, 42, 0.1);
            border-bottom: 1px solid rgba(42, 42, 42, 0.1);
            padding: 0.8rem 0;
        }
        
        .btn {
            background: transparent;
            border: 1px solid var(--fg);
            color: var(--fg);
            padding: 0.9rem 2rem;
            font-size: 0.65rem;
            letter-spacing: 0.25em;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            text-transform: uppercase;
            font-weight: 400;
            pointer-events: auto;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--fg);
            transition: left 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: -1;
        }
        
        .btn:hover::before, .btn:active::before {
            left: 0;
        }
        
        .btn:hover, .btn:active {
            color: var(--bg);
            box-shadow: 0 0 20px rgba(42, 42, 42, 0.15);
        }
        
        .btn.accent {
            border-color: rgba(42, 42, 42, 0.3);
            color: var(--fg);
        }
        
        .btn.accent::before {
            background: var(--fg);
        }
        
        .btn.accent:hover, .btn.accent:active {
            color: var(--bg);
            box-shadow: 0 0 20px rgba(42, 42, 42, 0.2);
        }
        
        @media (max-width: 768px) {
            .btn {
                padding: 1rem 2rem;
                font-size: 0.75rem;
            }
        }
        
        .info-container {
            max-width: 520px;
            width: 90%;
            padding: 3rem 2rem;
            position: relative;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(42, 42, 42, 0.15);
            pointer-events: auto;
        }
        
        .info-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(42, 42, 42, 0.3) 50%, transparent);
            pointer-events: none;
        }
        
        .info-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(42, 42, 42, 0.2) 50%, transparent);
            pointer-events: none;
        }
        
        .info-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .info-container {
                width: 95%;
                padding: 2rem 1.5rem;
            }
        }
        
        .form-title {
            font-size: clamp(1.8rem, 6vw, 2.8rem);
            margin-bottom: 3rem;
            letter-spacing: 0.02em;
            font-weight: 400;
            text-align: center;
            position: relative;
            color: var(--fg);
            pointer-events: none;
        }
        
        .form-title::after {
            content: '';
            position: absolute;
            bottom: -1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 1px;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            pointer-events: none;
        }
        
        .form-field {
            margin-bottom: 2.5rem;
            position: relative;
            pointer-events: auto;
        }
        
        .form-field label {
            display: block;
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.8rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-weight: 500;
            pointer-events: none;
        }
        
        .form-field input,
        .form-field select {
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-bottom: 1px solid rgba(192, 38, 37, 0.3);
            color: var(--fg);
            padding: 1rem 0;
            font-size: 1.1rem;
            font-family: 'Inter', sans-serif;
            font-weight: 300;
            transition: border-color 0.3s, box-shadow 0.3s;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 0;
            pointer-events: auto;
        }
        
        .form-field input {
            cursor: text;
        }
        
        .form-field select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%232a2a2a' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right center;
            padding-right: 2rem;
        }
        
        .form-field input:focus,
        .form-field select:focus {
            outline: none;
            border-bottom-color: var(--accent);
            box-shadow: 0 2px 10px rgba(192, 38, 37, 0.2);
        }
        
        .form-field input::placeholder {
            color: rgba(42, 42, 42, 0.4);
            font-weight: 300;
        }

        #scent-screen {
            flex-direction: column;
            padding: 1.5rem 1rem;
            overflow-y: auto;
            overflow-x: hidden;
            align-items: stretch;
            -webkit-overflow-scrolling: touch;
        }
        
        .scent-science-note {
            background: rgba(255, 255, 255, 0.30);
            border-left: 2px solid rgba(192, 38, 37, 0.2);
            padding: 1rem 1.2rem;
            margin: 0.75rem auto 0;
            max-width: 100%;
            width: 100%;
            font-size: 0.7rem;
            line-height: 1.6;
            color: rgba(42, 42, 42, 0.7);
            letter-spacing: 0.03em;
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.02);
        }
        
        .scent-science-note strong {
            color: var(--accent);
            font-weight: 500;
        }
        
        .scent-science-note em {
            font-style: normal;
            color: rgba(42, 42, 42, 0.9);
            border-bottom: 1px dotted rgba(192, 38, 37, 0.4);
        }
        
        @media (max-width: 768px) {
            #scent-screen {
                padding: 4rem 0.75rem 1rem;
                overflow-y: auto;
            }
            .lumen-name { font-size: 0.9rem; letter-spacing: 0.05em; }
            .lumen-value { font-size: 1.5rem; }
        }
        
        .scent-header {
            text-align: center;
            margin-bottom: 1rem;
            flex-shrink: 0;
            padding-top: 1rem;
        }
        
        @media (max-width: 768px) {
            .scent-header {
                margin-bottom: 1rem;
                padding-top: 0;
            }
            .scent-header h2 {
                font-size: 1.8rem !important;
                line-height: 1.3;
                margin-bottom: 1rem;
            }
            .scent-header p {
                font-size: 0.75rem !important;
                line-height: 1.5;
                padding: 0 0.5rem;
            }
        }
        
        .scent-header h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            font-weight: 300;
            margin-bottom: 0.8rem;
            letter-spacing: 0.1em;
            text-shadow: none;
            position: relative;
            display: inline-block;
        }
        
        .scent-header h2::after {
            content: '';
            position: absolute;
            bottom: -0.3rem;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, rgba(42, 42, 42, 0.3), transparent);
        }

        .scent-intro-box {
            font-size: clamp(0.65rem, 1.8vw, 0.8rem);
            line-height: 1.75;
            color: rgba(42, 42, 42, 0.65);
            width: 100%;
            margin: 1.5rem auto 0;
            padding: 1.2rem 1.5rem;
            border-left: 1px solid rgba(42, 42, 42, 0.12);
            text-align: left;
            white-space: pre-wrap;
            background: rgba(255, 255, 255, 0.25);
            flex-shrink: 0;
            font-weight: 300;
            backdrop-filter: blur(12px);
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.02);
        }
        
        :root[data-theme="dark"] .scent-intro-box {
            background: rgba(40, 40, 40, 0.4);
            border-left-color: rgba(255, 255, 255, 0.1);
            color: rgba(230, 230, 230, 0.7);
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
        }
        
        @media (max-width: 768px) {
            .scent-intro-box {
                font-size: 0.75rem;
                line-height: 1.6;
                padding: 1rem 1rem;
                margin: 1rem auto 0.75rem;
            }
        }
        
        .scent-header p {
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            color: rgba(42, 42, 42, 0.6);
            letter-spacing: 0.05em;
        }
        
        #scent-pages {
            position: relative;
            width: 100%;
            max-width: 600px;
            flex: 1;
            margin: 0 auto 1rem;
            overflow: hidden;
            min-height: 500px;
        }
        
        @media (max-width: 768px) {
            #scent-pages {
                min-height: 550px;
            }
        }
        
        .scent-page {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%) scale(0.95);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 2rem 1rem 1rem;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y pinch-zoom;
        }
        
        @media (max-width: 768px) {
            .scent-page {
                padding: 1.5rem 0.75rem 0.75rem;
                touch-action: pan-y pinch-zoom;
            }
        }
        
        .scent-page.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0) scale(1);
        }
        
        .scent-page.prev {
            transform: translateX(-100%) scale(0.95);
        }
        
        .lumen-label {
            text-align: center;
            pointer-events: none;
            margin-top: 1rem;
            padding: 0 1rem;
            flex-shrink: 0;
        }
        
        .lumen-instruction {
            font-size: 0.7rem;
            color: rgba(42, 42, 42, 0.6);
            margin-top: 0.8rem;
            text-align: center;
            line-height: 1.4;
        }
        
        .lumen-name {
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        
        .lumen-value {
            font-size: clamp(1.8rem, 7vw, 2.5rem);
            color: var(--accent);
            font-weight: 500;
            opacity: 0.9;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
            margin-bottom: 0.3rem;
        }
        
        .scent-pagination {
            display: flex;
            justify-content: center;
            gap: 0.8rem;
            margin: 0.75rem 0;
            flex-shrink: 0;
        }
        
        .page-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(42, 42, 42, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .page-dot.active {
            background: var(--accent);
            transform: scale(1.3);
            box-shadow: 0 0 10px var(--accent);
        }
        
        .scent-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 1rem 1rem 1.5rem;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-controls {
                gap: 0.5rem;
                padding: 0.75rem 0.5rem 1rem;
            }
            .scent-controls .btn {
                padding: 0.8rem 1.5rem;
                font-size: 0.65rem;
            }
        }
        
        #module-selection-screen {
            padding: 0;
            align-items: center;
            overflow: hidden;
        }
        
        @media (max-width: 768px) {
            #module-selection-screen {
                padding: 1.5rem 0.5rem;
            }
        }
        
        .module-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .module-header {
            text-align: center;
            padding: 2rem 1rem 1.5rem;
            flex-shrink: 0;
        }
        
        .module-header h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            font-weight: 300;
            margin-bottom: 0.8rem;
            letter-spacing: 0.1em;
            position: relative;
            display: inline-block;
        }
        
        .module-header h2::after {
            content: '';
            position: absolute;
            bottom: -0.3rem;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, rgba(42, 42, 42, 0.3), transparent);
        }
        
        #module-pages-container {
            position: relative;
            width: 100%;
            flex: 1;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .module-page {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%) scale(0.95);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y pinch-zoom;
        }
        
        .module-page.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0) scale(1);
            z-index: 2;
        }
        
        .module-page.prev {
            transform: translateX(-100%) scale(0.95);
        }
        
        @media (max-width: 768px) {
            .module-page {
                padding: 1.5rem 0.75rem 2rem 0.75rem; /* 底部增加padding确保START按钮可见 */
                align-items: flex-start; /* 从顶部开始对齐，便于滚动 */
            }
        }
        
        .module-cover {
            width: 100%;
            max-width: 800px;
            min-height: 500px;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 3rem 2.5rem;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.28), rgba(255, 255, 255, 0.18));
            backdrop-filter: blur(24px) saturate(120%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.08),
                0 2px 8px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        :root[data-theme="dark"] .module-cover {
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.6), rgba(30, 30, 30, 0.5));
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .module-cover::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        }
        
        :root[data-theme="dark"] .module-cover::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }
        
        @media (max-width: 768px) {
            .module-cover {
                padding: 1.5rem 1.2rem;
                min-height: auto;
                max-height: 85vh;
            }
        }
        
        .module-cover-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.4;
            pointer-events: none;
            overflow: hidden;
        }
        
        .module-cover-content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .module-cover-title {
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 300;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            line-height: 1.1;
            color: var(--fg);
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            position: relative;
        }
        
        .module-cover-subtitle {
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: rgba(42, 42, 42, 0.5);
            margin-bottom: 2.5rem;
            font-weight: 300;
            position: relative;
            padding-bottom: 0.5rem;
        }
        
        .module-cover-subtitle::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 3rem;
            height: 1px;
            background: linear-gradient(90deg, rgba(42, 42, 42, 0.3), transparent);
        }
        
        .module-cover-description {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .module-cover-text {
            font-size: clamp(0.85rem, 2vw, 1rem);
            line-height: 1.8;
            color: rgba(42, 42, 42, 0.75);
            font-weight: 300;
        }
        
        .module-cover-science {
            background: linear-gradient(120deg, rgba(192, 38, 37, 0.05), rgba(192, 38, 37, 0.08));
            border-left: 2px solid rgba(192, 38, 37, 0.25);
            padding: 1.2rem 1.5rem;
            font-size: clamp(0.75rem, 1.8vw, 0.85rem);
            line-height: 1.7;
            color: rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(10px);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
        }
        
        .module-cover-science::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, rgba(192, 38, 37, 0.4), transparent);
        }
        
        .module-cover-science strong {
            color: var(--accent);
            font-weight: 500;
        }
        
        .module-cover-actions {
            display: flex;
            gap: 1rem;
            margin-top: auto;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(42, 42, 42, 0.08);
        }
        
        @media (max-width: 768px) {
            .module-cover-title {
                font-size: clamp(1.8rem, 7vw, 2.5rem);
                margin-bottom: 0.3rem;
            }
            
            .module-cover-subtitle {
                margin-bottom: 1.5rem;
                font-size: 0.65rem;
            }
            
            .module-cover-description {
                gap: 1rem;
                margin-bottom: 1.2rem;
            }
            
            .module-cover-text {
                font-size: 0.85rem;
                line-height: 1.6;
            }
            
            .module-cover-science {
                padding: 0.9rem 1.2rem;
                font-size: 0.75rem;
                line-height: 1.6;
            }
            
            .module-cover-actions {
                padding-top: 1rem;
            }
        }
        
        .module-status {
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            padding: 0.4rem 0.8rem;
            background: linear-gradient(135deg, rgba(0, 204, 0, 0.12), rgba(0, 204, 0, 0.08));
            color: var(--green-hit);
            border: 1px solid rgba(0, 204, 0, 0.25);
            display: inline-block;
            margin-bottom: 1rem;
            box-shadow: 0 2px 8px rgba(0, 204, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
        }
        
        .module-status.incomplete {
            background: linear-gradient(135deg, rgba(42, 42, 42, 0.06), rgba(42, 42, 42, 0.04));
            color: rgba(42, 42, 42, 0.5);
            border-color: rgba(42, 42, 42, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        .module-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.8rem;
            padding: 1.5rem 0;
            flex-shrink: 0;
        }
        
        .module-page-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(42, 42, 42, 0.25);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .module-page-dot.active {
            background: var(--accent);
            transform: scale(1.3);
            box-shadow: 0 0 10px var(--accent);
        }
        
        .module-nav-btn {
            background: transparent;
            border: 1px solid rgba(42, 42, 42, 0.15);
            color: var(--fg);
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .module-nav-btn:hover {
            background: rgba(42, 42, 42, 0.05);
        }
        
        .module-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .difficulty-panel {
            padding: 1.5rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(42, 42, 42, 0.08);
            flex-shrink: 0;
        }
        
        .difficulty-control {
            max-width: 450px;
            margin: 0 auto 2.5rem;
            padding: 1.5rem 1.5rem;
            background: rgba(192, 38, 37, 0.08);
            border-radius: 2px;
            border: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (max-width: 768px) {
            .difficulty-control {
                padding: 1.2rem 1rem;
                margin-bottom: 2rem;
            }
        }
        
        .difficulty-control label {
            display: block;
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-weight: 500;
            margin-bottom: 0.3rem;
        }
        
        .difficulty-desc {
            font-size: 0.6rem;
            color: rgba(42, 42, 42, 0.6);
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .difficulty-slider {
            flex: 1;
            height: 2px;
            background: var(--gray);
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
        }
        
        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .difficulty-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent);
            cursor: pointer;
            border: none;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .difficulty-value {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: 500;
            min-width: 3rem;
            text-align: right;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        .module-grid {
            display: none; /* Replaced by module-pages-container */
        }
        
        .module-cell {
            display: none; /* Replaced by module-cover */
        }
        
        @media (min-width: 1100px) {
             .module-grid { grid-template-columns: repeat(3, 1fr); }
             .module-cell:nth-child(3n) { border-right: none; }
        }
        @media (min-width: 581px) and (max-width: 1099px) {
             .module-grid { grid-template-columns: repeat(2, 1fr); }
             .module-cell:nth-child(2n) { border-right: none; }
        }
        
        @media (max-width: 580px) {
            .module-cell {
                border-right: none;
                padding: 1.8rem 1.2rem;
            }
        }
        
        .module-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 42, 42, 0.03);
            opacity: 0;
            transition: opacity 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
        }
        
        .module-cell:hover::before, .module-cell:active::before {
            opacity: 1;
        }
        
        .module-cell:hover, .module-cell:active {
            box-shadow: inset 0 0 40px rgba(42, 42, 42, 0.05);
        }
        
        .module-cell.completed::after {
            content: '✓';
            position: absolute;
            top: 1rem;
            right: 1rem;
            color: var(--fg);
            font-size: 1.2rem;
            opacity: 0.5;
        }
        
        .module-cell h3 {
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            font-weight: 300;
            margin-bottom: 0.6rem;
            letter-spacing: 0.08em;
            position: relative;
            padding-bottom: 0.5rem;
        }
        
        .module-cell h3::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 2rem;
            height: 1px;
            background: rgba(42, 42, 42, 0.25);
        }
        
        .module-cell .subtitle {
            font-size: 0.6rem;
            color: rgba(42, 42, 42, 0.5);
            margin-bottom: 0.8rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-weight: 300;
        }
        
        .module-cell .description {
            font-size: 0.75rem;
            line-height: 1.65;
            color: rgba(42, 42, 42, 0.65);
            font-weight: 300;
        }
        
        #game-ui {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            max-width: 85%;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-ui {
                top: 6rem;
                max-width: 90%;
            }
        }
        
        #game-ui.active { opacity: 1; }
        
        #game-ui h3 {
            font-size: clamp(1.3rem, 5vw, 2rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        #game-ui p {
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            color: rgba(42, 42, 42, 0.7);
        }
        
        #game-stats {
            position: absolute;
            top: 2rem;
            right: 1rem;
            text-align: right;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-stats {
                top: 1.5rem;
                right: 0.75rem;
            }
        }
        
        #game-stats.active { opacity: 1; }
        
        .stat-row {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.4rem;
            letter-spacing: 0.1em;
            font-weight: 400;
        }
        
        .stat-value {
            color: var(--accent);
            font-weight: 500;
            margin-left: 0.5rem;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        #back-btn {
            position: absolute;
            top: 2rem;
            left: 1rem;
            opacity: 0;
            transition: opacity 0.5s;
            padding: 0.7rem 1.5rem;
            font-size: 0.65rem;
            pointer-events: auto;
        }
        
        @media (max-width: 768px) {
            #back-btn {
                top: 1.5rem;
                left: 0.75rem;
                padding: 0.65rem 1.2rem;
            }
        }
        
        #back-btn.active { opacity: 1; }
        
        #tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(245, 245, 240, 0.96);
            z-index: 99;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }
        #tutorial-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        .tutorial-card {
            max-width: 500px;
            width: 90%;
            padding: 2.5rem 1.5rem;
            border: 2px solid var(--accent);
            text-align: center;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.3);
        }
        .tutorial-card h3 {
            font-size: clamp(1.5rem, 5vw, 2rem);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        .tutorial-card p {
            font-size: clamp(0.85rem, 3vw, 1.1rem);
            line-height: 1.5;
            margin-bottom: 1.5rem;
            color: var(--fg);
        }
        .tutorial-card button {
            margin-top: 1rem;
        }

        .game-intro-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 80%;
            font-size: clamp(0.8rem, 2.2vw, 1.0rem);
            color: var(--fg);
            text-align: center;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.0s;
            line-height: 1.8;
            letter-spacing: 0.12em;
            font-weight: 200;
            text-transform: uppercase;
            border: 1px solid rgba(42, 42, 42, 0.15);
            background: rgba(255, 255, 255, 0.92);
            padding: 1.5rem 2.5rem;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
        }
        
        #question-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid var(--accent);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.3);
        }
        
        @media (max-width: 768px) {
            #question-overlay {
                padding: 1.5rem;
                width: 95%;
            }
        }
        
        #question-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        #question-text {
            font-size: clamp(1rem, 3vw, 1.2rem);
            margin-bottom: 1.5rem;
            font-weight: 400;
            text-align: center;
            line-height: 1.4;
        }
        
        .answer-option {
            background: transparent;
            border: 1px solid rgba(192, 38, 37, 0.3);
            padding: 1rem;
            margin-bottom: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            width: 100%;
            text-align: left;
            color: var(--fg);
        }
        
        .answer-option:hover, .answer-option:active {
            background: rgba(192, 38, 37, 0.2);
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        /* Answer feedback states */
        .answer-option.correct {
            background: rgba(76, 175, 80, 0.3) !important;
            border-color: #4caf50 !important;
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.4) !important;
            animation: correctPulse 0.6s ease;
        }
        
        .answer-option.wrong {
            background: rgba(244, 67, 54, 0.3) !important;
            border-color: #f44336 !important;
            box-shadow: 0 0 25px rgba(244, 67, 54, 0.4) !important;
            animation: wrongShake 0.4s ease;
        }
        
        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        /* Category badge styling */
        .category-badge {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            background: rgba(192, 38, 37, 0.15);
            border: 1px solid rgba(192, 38, 37, 0.3);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--accent);
            letter-spacing: 0.5px;
        }
        
        .results-wrapper {
            max-width: 800px;
            width: 95%;
            padding: 2rem 1rem;
            align-self: flex-start;
            margin-top: 2rem;
        }
        
        @media (max-width: 768px) {
            .results-wrapper {
                width: 98%;
                padding: 1rem 0.5rem;
            }
        }
        
        .results-header {
            font-size: clamp(1.8rem, 7vw, 3rem);
            font-weight: 400;
            text-align: center;
            margin-bottom: 2rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.3);
        }
        
        .results-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1px;
            background: rgba(192, 38, 37, 0.2);
            border: 1px solid rgba(192, 38, 37, 0.2);
            margin-bottom: 2rem;
        }
        
        .summary-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .summary-item {
                padding: 0.8rem 0.5rem;
            }
            .summary-item h4 {
                 font-size: 0.55rem;
            }
             .summary-item .value {
                font-size: clamp(1.2rem, 4vw, 2rem);
            }
        }
        
        .summary-item h4 {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.6rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .summary-item .value {
            font-size: clamp(1.5rem, 5vw, 2.6rem);
            font-weight: 400;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        .results-details {
            margin-bottom: 2rem;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem 0.2rem;
            border-bottom: 1px solid rgba(192, 38, 37, 0.2);
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            font-size: 0.8rem;
            font-weight: 400;
        }
        
        .detail-value {
            font-size: 0.8rem;
            color: var(--accent);
            font-weight: 500;
            text-align: right;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        #scent-wheel-container {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        #scent-wheel {
            width: 100%;
            max-width: 400px;
            height: 400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            #scent-wheel {
                max-width: 320px;
                height: 320px;
            }
        }
        
        #report-visualization {
            width: 100%;
            height: 300px;
            margin-bottom: 2rem;
        }

        .recommendation-box {
            background: rgba(192, 38, 37, 0.08);
            padding: 2rem 1.5rem;
            text-align: center;
            margin-bottom: 2rem;
            border: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (max-width: 768px) {
            .recommendation-box {
                padding: 1.5rem 1rem;
            }
        }
        
        .recommendation-box h3 {
            font-size: clamp(0.95rem, 3vw, 1.2rem);
            font-weight: 400;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }
        
        .recommendation-box p {
            font-size: clamp(0.95rem, 3vw, 1.3rem);
            line-height: 1.6;
        }
        
        /* === NEW: Scientific Evidence & Visualization Styles === */
        .results-wrapper {
            overflow-y: auto;
            max-height: 90vh;
        }
        
        .scientific-section {
            background: rgba(245, 245, 240, 0.6);
            border: 1px solid rgba(192, 38, 37, 0.15);
            padding: 1.5rem;
            margin: 2rem 0;
        }
        
        .scientific-section h3 {
            font-size: 1.1rem;
            font-weight: 400;
            letter-spacing: 0.08em;
            margin-bottom: 1rem;
            color: var(--accent);
        }
        
        .scientific-section p {
            font-size: 0.8rem;
            line-height: 1.7;
            color: rgba(42, 42, 42, 0.8);
        }
        
        .citation {
            font-size: 0.7rem;
            color: rgba(42, 42, 42, 0.6);
            font-style: italic;
            margin-top: 0.8rem;
            border-left: 2px solid rgba(192, 38, 37, 0.3);
            padding-left: 1rem;
            line-height: 1.5;
        }
        
        .toc-risk-container {
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(192, 38, 37, 0.1);
        }
        
        .toc-risk-container h4 {
            font-size: 0.95rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            margin-bottom: 1.2rem;
        }
        
        .risk-meter {
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, 
                #00cc00 0%, 
                #88cc00 33%, 
                #ffaa00 66%, 
                #ff6600 100%);
            position: relative;
            margin: 1rem 0;
        }
        
        .risk-indicator {
            position: absolute;
            top: -10px;
            width: 2px;
            height: 28px;
            background: var(--fg);
            transition: left 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .risk-indicator::after {
            content: '▼';
            position: absolute;
            top: -18px;
            left: -6px;
            font-size: 0.8rem;
        }
        
        .risk-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(42, 42, 42, 0.5);
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }
        
        #trajectory-chart {
            width: 100%;
            height: 220px;
            margin: 1.5rem 0;
        }
        
        .trajectory-section {
            margin: 2rem 0;
        }
        
        /* Report Section Titles - 统一高级感标题样式 */
        .report-section-title {
            color: var(--accent) !important;
            font-size: 1.3rem !important;
            margin-bottom: 1.2rem !important;
            font-weight: 400 !important;
            letter-spacing: 0.08em !important;
            text-transform: none !important;
            border-bottom: 1px solid rgba(192, 38, 37, 0.15);
            padding-bottom: 0.6rem;
        }
        
        .report-section-title.fingerprint-title {
            font-size: 1rem !important;
            letter-spacing: 0.12em !important;
            font-weight: 300 !important;
            text-transform: uppercase;
            color: rgba(42, 42, 42, 0.7) !important;
            border-bottom: none;
            padding-bottom: 0.3rem;
        }
        
        @media (max-width: 768px) {
            .report-section-title {
                font-size: 1.1rem !important;
            }
            .report-section-title.fingerprint-title {
                font-size: 0.85rem !important;
            }
        }
        
        .trajectory-interpretation {
            font-size: 0.8rem;
            line-height: 1.8;
            color: rgba(42, 42, 42, 0.85);
            font-weight: 400;
        }
        
        .trajectory-interpretation .highlight {
            color: var(--accent);
            font-weight: 500;
        }
        
        .status {
            display: inline-block;
            padding: 0.4rem 1rem;
            margin: 0.5rem 0;
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            font-weight: 500;
        }
        
        .status.good {
            background: rgba(0, 204, 0, 0.1);
            color: #00aa00;
            border: 1px solid rgba(0, 170, 0, 0.3);
        }
        
        .status.warning {
            background: rgba(255, 170, 0, 0.1);
            color: #ff8800;
            border: 1px solid rgba(255, 136, 0, 0.3);
        }
        
        /* Enlarged Brain Radar Chart */
        #brain-radar {
            max-width: 420px;
            width: 100%;
            height: auto;
            margin: 2rem auto;
            display: block;
        }
        
        @media (max-width: 768px) {
            #brain-radar {
                max-width: 100%;
                margin: 1.5rem auto;
            }
        }
        
        .radar-legend {
            display: flex;
            justify-content: center;
            gap: 1.8rem;
            font-size: 0.7rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
            font-weight: 400;
        }
        
        .radar-legend span {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }
        
        .radar-legend span::before {
            content: '';
            width: 14px;
            height: 14px;
            display: inline-block;
            border-radius: 50%;
        }
        
        .radar-legend .normal::before {
            background: rgba(0, 204, 0, 0.2);
            border: 2px solid #00cc00;
        }
        
        .radar-legend .mild::before {
            background: rgba(255, 170, 0, 0.2);
            border: 2px solid #ffaa00;
        }
        
        .radar-legend .moderate::before {
            background: rgba(192, 38, 37, 0.2);
            border: 2px solid var(--accent);
        }
        
        .pattern-type {
            background: rgba(255, 255, 255, 0.7);
            border-left: 3px solid var(--accent);
            padding: 1.2rem;
            margin: 1rem 0;
        }
        
        .pattern-type h4 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 0.6rem;
            letter-spacing: 0.05em;
        }
        
        .pattern-type .percentage {
            font-size: 0.7rem;
            color: rgba(42, 42, 42, 0.6);
            margin: 0.5rem 0;
        }
        
        .pattern-type .action {
            font-size: 0.75rem;
            margin-top: 0.9rem;
            padding-top: 0.9rem;
            border-top: 1px solid rgba(192, 38, 37, 0.15);
        }
        
        .prediction-box {
            background: rgba(0, 204, 0, 0.05);
            border: 1px solid rgba(0, 204, 0, 0.2);
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .prediction-box h4 {
            font-size: 0.9rem;
            margin-bottom: 0.8rem;
            font-weight: 500;
            letter-spacing: 0.05em;
        }
        
        .prediction-box ul {
            list-style: none;
            padding: 0;
        }
        
        .prediction-box li {
            font-size: 0.75rem;
            padding: 0.4rem 0;
            display: flex;
            justify-content: space-between;
        }
        
        .prediction-box .improve {
            color: #00aa00;
            font-weight: 500;
        }
        
        .prediction-box .stable {
            color: rgba(42, 42, 42, 0.6);
        }
        
        .dot-pattern {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25%;
            background-image: radial-gradient(circle, rgba(42, 42, 42, 0.1) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.3;
            pointer-events: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.8s ease forwards;
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--gray); }
        ::-webkit-scrollbar-thumb { background: var(--accent); }

        #pattern-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(3rem, 10vw, 6rem);
            color: var(--accent);
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.5);
        }
        
        #pattern-countdown.active {
            opacity: 1;
        }
        
        #crystal-container {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            position: relative;
        }
        
        #crystal-canvas {
            width: 100%;
            height: 100%;
        }
        
        #crystal-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
            pointer-events: none;
        }

        #reflex-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vmin;
            max-height: 90vmin;
            aspect-ratio: 1 / 1;
            z-index: 5;
            border: none;
            background: transparent;
        }

        #game-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(4rem, 15vw, 8rem);
            color: var(--accent);
            font-weight: 700;
            opacity: 0;
            z-index: 200;
            pointer-events: none;
            transition: opacity 0.2s;
            text-shadow: 0 0 50px rgba(192, 38, 37, 0.5);
        }
        
        .game-intro-text.active-intro {
            opacity: 1;
        }

        #report-visualization .bar {
            transition: fill 0.3s, opacity 0.3s;
        }
        #report-visualization .tick line, #report-visualization .domain {
            stroke: rgba(192, 38, 37, 0.3);
        }
        #report-visualization text {
            fill: #2a2a2a; 
        }
        
        #mod4-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vw;
            max-height: 80vh;
            border: 2px solid rgba(192, 38, 37, 0.3);
            background: #1a1a1a;
        }

    </style>
</head>
<body>
    <div id="cursor"></div>
    <canvas id="canvas3d"></canvas>
    
    <div id="lang-switch">
        <button class="lang-btn active" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="zh">中</button>
    </div>
    
    <div id="ui-layer">
        <div id="welcome-screen" class="screen active">
            <h1 class="welcome-logo serif">NeuroScent</h1>
            <p class="welcome-subtitle" data-i18n="welcome_sub">Personalized Olfactory-Cognitive Training</p>
            <p style="font-size: 0.65rem; color: rgba(42, 42, 42, 0.5); letter-spacing: 0.1em; margin-top: 2rem;">
                TAP ANYWHERE TO BEGIN
            </p>
            <div class="dot-pattern"></div>
        </div>
        
        <div id="info-screen" class="screen" style="pointer-events: none;">
            <div class="info-container fade-in" style="pointer-events: auto;">
                <h2 class="form-title serif" data-i18n="info_title">Profile</h2>
                <div class="form-field">
                    <label data-i18n="info_name">Name</label>
                    <input type="text" id="user-name" placeholder="Enter your name" autocomplete="name">
                </div>
                <div class="form-field">
                    <label data-i18n="info_age">Age</label>
                    <input type="number" id="user-age" placeholder="Enter your age" min="1" max="120" autocomplete="age">
                </div>
                <div class="form-field">
                    <label data-i18n="info_gender">Gender</label>
                    <select id="user-gender">
                        <option value="">Select gender</option>
                        <option value="male" data-i18n="info_male">Male / 男</option>
                        <option value="female" data-i18n="info_female">Female / 女</option>
                        <option value="nonbinary" data-i18n="info_nonbinary">Nonbinary / 非二元</option>
                        <option value="prefer-not" data-i18n="info_prefer_not">Prefer not to say / 不愿透露</option>
                    </select>
                </div>
                <div class="form-field">
                    <label data-i18n="info_status">Status</label>
                    <select id="user-status">
                        <option value="">Select status</option>
                        <option value="early-stage" data-i18n="info_early">Early Stage / 早期</option>
                        <option value="moderate" data-i18n="info_moderate">Moderate / 中度</option>
                        <option value="control" data-i18n="info_control">Control / 对照</option>
                    </select>
                </div>
                <button class="btn accent" id="info-submit" style="display: block; width: 100%; margin-top: 2rem;">
                    <span data-i18n="btn_continue">CONTINUE</span>
                </button>
            </div>
        </div>
        
        <div id="scent-screen" class="screen">
            <div class="scent-header fade-in">
                <h2 class="serif" data-i18n="scent_title">Olfactory Profile</h2>
                <p data-i18n="scent_desc">Drag outward from center to set preference</p>
            </div>

            <div id="scent-pages">
                <div class="scent-page active" data-page="0"></div>
                <div class="scent-page" data-page="1"></div>
                <div class="scent-page" data-page="2"></div>
                <div class="scent-page" data-page="3"></div>
                <div class="scent-page" data-page="4"></div>
                <div class="scent-page" data-page="5"></div>
            </div>
            <div class="scent-pagination">
                <div class="page-dot active" data-page="0"></div>
                <div class="page-dot" data-page="1"></div>
                <div class="page-dot" data-page="2"></div>
                <div class="page-dot" data-page="3"></div>
                <div class="page-dot" data-page="4"></div>
                <div class="page-dot" data-page="5"></div>
            </div>
            <div class="scent-controls">
                <button class="btn" id="scent-prev" style="opacity: 0.3;">
                    <span>← PREV</span>
                </button>
                <button class="btn accent" id="scent-submit">
                    <span data-i18n="btn_continue">CONTINUE</span>
                </button>
                <button class="btn" id="scent-next">
                    <span>NEXT →</span>
                </button>
            </div>
        </div>
        
        <div id="module-selection-screen" class="screen">
            <div class="module-wrapper">
                <div class="module-header">
                    <h2 class="serif" data-i18n="modules_title">Training Modules</h2>
                </div>
                
                <div id="module-pages-container">
                    <!-- Module pages will be dynamically generated -->
                </div>
                
                <div class="module-pagination">
                    <button class="module-nav-btn" id="module-prev">←</button>
                    <div class="module-page-dot active" data-page="0"></div>
                    <div class="module-page-dot" data-page="1"></div>
                    <div class="module-page-dot" data-page="2"></div>
                    <div class="module-page-dot" data-page="3"></div>
                    <div class="module-page-dot" data-page="4"></div>
                    <div class="module-page-dot" data-page="5"></div>
                    <button class="module-nav-btn" id="module-next">→</button>
                </div>
                
                <div class="difficulty-panel">
                    <label data-i18n="difficulty_label">Simulate Patient tOC</label>
                    <div class="slider-container" style="max-width: 400px; margin: 1rem auto 0;">
                        <input type="range" class="difficulty-slider" id="toc-slider" min="0" max="100" value="20">
                        <div class="difficulty-value" id="toc-value">20</div>
                    </div>
                </div>
                
                <div style="padding: 1rem; text-align: center;">
                    <button class="btn accent" id="finish-btn">
                        <span data-i18n="btn_finish">COMPLETE SESSION</span>
                    </button>
                </div>
                
                <div class="module-grid" id="module-gallery" style="display: none;"></div>
            </div>
        </div>
        
        <div id="game-screen" class="screen">
            <button class="btn" id="back-btn">
                <span data-i18n="btn_back">← BACK</span>
            </button>
            <div id="game-ui">
                <h3 class="serif" id="game-title"></h3>
                <p id="game-instruction"></p>
            </div>
            <div id="game-stats">
                <div class="stat-row"><span data-i18n="stat_time">Time</span><span class="stat-value" id="stat-time">0s</span></div>
                <div class="stat-row"><span data-i18n="stat_score">Score</span><span class="stat-value" id="stat-score">0</span></div>
                <!-- 自适应难度显示 (仅模块3可见) -->
                <div id="difficulty-display" class="stat-row" style="display: none; margin-top: 0.8rem; border-top: 1px solid rgba(192, 38, 37, 0.2); padding-top: 0.6rem;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; gap: 0.5rem; margin-bottom: 0.3rem;">
                        <span style="font-size: 0.7rem;">Level</span>
                        <span class="stat-value" id="current-level" style="font-size: 1.2rem;">2</span>
                    </div>
                    <div style="font-size: 0.55rem; opacity: 0.7; text-align: right;">
                        <div id="streak-correct" style="color: #00cc00; margin-bottom: 0.2rem;">✓ Streak: 0/5</div>
                        <div id="streak-wrong" style="color: #ff6600;">✗ Streak: 0/3</div>
                    </div>
                </div>
            </div>
            <div id="game-intro-text" class="game-intro-text zh"></div>
            <div id="game-countdown"></div>
            
            <div id="question-overlay">
                <h3 id="question-text"></h3>
                <div id="answer-options"></div>
            </div>
            
            <div id="pattern-countdown"></div>
            
            <div id="crystal-container" style="display: none;">
                <canvas id="crystal-canvas"></canvas>
                <div id="crystal-indicator"></div>
            </div>

            <canvas id="reflex-canvas" style="display: none;"></canvas>
            <canvas id="mod4-canvas" style="display: none;"></canvas>
            
            <div id="tutorial-overlay">
                <div class="tutorial-card">
                    <h3 class="serif" id="tutorial-title"></h3>
                    <p id="tutorial-text"></p>
                    <button class="btn accent" id="tutorial-start-btn">
                        <span data-i18n="btn_start_game">START TRAINING</span>
                    </button>
                </div>
            </div>

            <div class="dot-pattern"></div>
        </div>
        
        <div id="results-screen" class="screen">
            <div class="results-wrapper fade-in">
                <h2 class="results-header serif" data-i18n="results_title">Session Report</h2>
                
                <!-- Original Results Summary -->
                <div class="results-summary" id="results-summary"></div>
                <div class="results-details" id="results-details"></div>
                
                <!-- NEW: tOC Risk Assessment -->
                <div class="toc-risk-container">
                    <h4 data-i18n="toc_risk_title">您的tOC风险评分</h4>
                    <div id="toc-risk-display"></div>
                    <div class="risk-meter">
                        <div class="risk-indicator" id="risk-indicator"></div>
                    </div>
                    <div class="risk-label">
                        <span>STABLE</span>
                        <span>MILD RISK</span>
                        <span>MODERATE RISK</span>
                        <span>HIGH RISK</span>
                    </div>
                    <p style="font-size: 0.75rem; color: rgba(42, 42, 42, 0.7); margin-top: 1rem; line-height: 1.6;" data-i18n="toc_risk_desc">
                        基于您当前的认知表现和tOC设置（<span id="current-toc-display"></span>），
                        系统计算出您的风险等级。持续追踪可帮助早期发现认知变化加速的信号。
                    </p>
                </div>
                
                <!-- NEW: 12-Month Trajectory Visualization -->
                <div class="trajectory-section">
                    <h3 class="serif report-section-title" data-i18n="trajectory_title">
                        12-Month Cognitive Trajectory (Simulated)
                    </h3>
                    <p style="font-size: 0.75rem; margin-bottom: 1rem; line-height: 1.6;" data-i18n="trajectory_desc">
                        以下为基于您当前表现的模拟追踪图。实际应用中需要持续12个月的定期评估。
                    </p>
                    <svg id="trajectory-chart"></svg>
                    <div class="trajectory-interpretation">
                        <p class="status good" data-i18n="status_stable">您的模拟变化率处于健康稳定区间</p>
                        <div class="prediction-box">
                            <h4 data-i18n="prediction_title">12个月预测（基于当前趋势）</h4>
                            <ul data-i18n-html="prediction_items">
                                <li><span>记忆功能：</span><span class="improve">+6-8% 改善</span></li>
                                <li><span>执行功能：</span><span class="stable">保持稳定</span></li>
                                <li><span>整体tOC：</span><span class="stable">+2-3 预计增长</span></li>
                            </ul>
                        </div>
                        <p style="font-size: 0.7rem; color: rgba(42, 42, 42, 0.6); margin-top: 1rem;" data-i18n="trajectory_disclaimer">
                            * 基于规范化模型的统计推断，非临床诊断
                        </p>
                    </div>
                </div>
                
                <!-- NEW: Brain Fingerprint Radar Chart -->
                <div class="trajectory-section">
                    <h3 class="serif report-section-title fingerprint-title" data-i18n="fingerprint_title">
                        Your Unique Cognitive Fingerprint
                    </h3>
                    <p style="font-size: 0.75rem; margin-bottom: 1.5rem; line-height: 1.6;" data-i18n="fingerprint_desc">
                        每个人的认知模式都是独特的。雷达图显示您在8个认知域的偏离程度（相对于正常范围）。
                    </p>
                    <canvas id="brain-radar"></canvas>
                    <div class="radar-legend">
                        <span class="normal" data-i18n="legend_normal">正常范围</span>
                        <span class="mild" data-i18n="legend_mild">轻度偏离 (-1σ)</span>
                        <span class="moderate" data-i18n="legend_moderate">中度偏离 (-2σ)</span>
                    </div>
                    
                    <!-- Pattern Interpretation -->
                    <div class="pattern-type" id="pattern-interpretation">
                        <h4 data-i18n="pattern_classification">您的认知模式分类</h4>
                        <p style="font-size: 0.8rem; margin: 0.8rem 0; line-height: 1.6;" data-i18n-html="pattern_desc_template">
                            基于您的雷达图模式，您被归类为<strong id="pattern-name">"平衡型"</strong>。
                            这意味着您的认知功能在各个领域相对均衡。
                        </p>
                        <p class="percentage" data-i18n-html="pattern_pct_template">
                            在研究人群中占比：<strong id="pattern-percentage">45%</strong>
                        </p>
                        <p class="action" data-i18n="pattern_recommendation">
                            <strong>个性化建议：</strong>继续全面的认知训练，同时使用均衡型气味组合（如薰衣草+迷迭香）以维持整体脑健康。
                        </p>
                    </div>
                </div>
                
                <!-- Original Scent Recommendation -->
                <div id="scent-wheel-container">
                    <div id="scent-wheel"></div>
                </div>
                <div id="report-visualization"></div>

                <div class="recommendation-box">
                    <h3 class="serif" data-i18n="results_scent">Recommended Scent Profile</h3>
                    <p id="scent-result"></p>
                </div>
                
                <button class="btn accent" id="restart-btn" style="display: block; margin: 0 auto;">
                    <span data-i18n="btn_restart">NEW SESSION</span>
                </button>
            </div>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        // ==================== RESOURCE MANAGER ====================
        // 统一资源管理系统，确保所有资源正确清理
        const ResourceManager = {
            resources: new Map(),
            
            register(id, resource) {
                this.resources.set(id, resource);
                console.log(`✓ Resource registered: ${id}`);
            },
            
            unregister(id) {
                const resource = this.resources.get(id);
                if (resource) {
                    if (resource.cleanup && typeof resource.cleanup === 'function') {
                        try {
                            resource.cleanup();
                            console.log(`✓ Resource cleaned up: ${id}`);
                        } catch (e) {
                            console.error(`✗ Error cleaning ${id}:`, e);
                        }
                    }
                    this.resources.delete(id);
                }
            },
            
            cleanupAll() {
                console.log(`🧹 Cleaning up ${this.resources.size} resources...`);
                const ids = Array.from(this.resources.keys());
                ids.forEach(id => this.unregister(id));
                this.resources.clear();
            },
            
            get(id) {
                return this.resources.get(id);
            }
        };
        
        // ==================== PERFORMANCE UTILITIES ====================
        const PerformanceUtils = {
            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },
            
            debounce(func, delay) {
                let timeoutId;
                return function(...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => func.apply(this, args), delay);
                };
            }
        };
        
        // ==================== SOUND SYSTEM ====================
        const Sound = {
            synths: {},
            ambient: null,
            noiseFilter: null,
            ambientLoop: null,
            initialized: false,
            ambientPianoLoop: null,
            vinylNoise: null,
            scentPanner: null,
            
            init() {
                if (this.initialized) return;
                try {
                    const reverb = new Tone.Reverb({ decay: 10, wet: 0.6, preDelay: 0.05 }).toDestination();
                    const filter = new Tone.Filter({ type: 'lowpass', frequency: 1200, rolloff: -24 }).connect(reverb);
                    const chorus = new Tone.Chorus({ frequency: 0.5, delayTime: 3.5, depth: 0.7, wet: 0.5 }).connect(filter);
                    const delay = new Tone.FeedbackDelay({ delayTime: '4n', feedback: 0.5, wet: 0.25 }).connect(chorus);
                    
                    this.noiseFilter = new Tone.Filter({ frequency: 800, type: 'bandpass', Q: 0.5 }).connect(reverb);
                    this.vinylNoise = new Tone.Noise({ type: 'pink', volume: -100 }).connect(this.noiseFilter);
                    this.vinylNoise.start();
                    
                    setTimeout(() => {
                        if (this.vinylNoise) {
                            this.vinylNoise.volume.rampTo(-34, 15);
                        }
                    }, 3000);
                    
                    this.ambient = new Tone.PolySynth(Tone.DuoSynth, {
                        volume: -26,
                        voice0: {
                            oscillator: { type: 'sine' },
                            envelope: { attack: 5, decay: 7, sustain: 0.25, release: 9 },
                            filter: { type: 'lowpass', frequency: 550 }
                        },
                        voice1: {
                            oscillator: { type: 'triangle' },
                            envelope: { attack: 9, decay: 5, sustain: 0.15, release: 11 },
                            filter: { type: 'lowpass', frequency: 350 }
                        }
                    }).connect(reverb);
                    
                    this.ambientPiano = new Tone.Sampler({
                        urls: { C4: "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YQAAAAA=" },
                        volume: -30,
                        release: 6
                    }).connect(reverb);
                    
                    this.scentPanner = new Tone.Panner3D({ 
                        positionX: 0, 
                        positionY: 0, 
                        positionZ: 0 
                    }).connect(reverb);
                    
                    this.synths = {
                        click: new Tone.MembraneSynth({ volume: -28, pitchDecay: 0.02, octaves: 1, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.1 } }).connect(delay),
                        hover: new Tone.Synth({ volume: -36, oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.04 } }).connect(filter),
                        success: new Tone.PolySynth(Tone.FMSynth, { 
                            volume: -22, 
                            harmonicity: 3.5, 
                            modulationIndex: 12,
                            envelope: { attack: 0.06, decay: 1.8, sustain: 0.12, release: 2.5 } 
                        }).connect(reverb),
                        slider: new Tone.Synth({ 
                            volume: -32, 
                            oscillator: { type: 'sine' }, 
                            envelope: { attack: 0.015, decay: 0.12, sustain: 0.08, release: 0.25 } 
                        }).connect(this.scentPanner),
                        scentDrag: new Tone.Synth({ 
                            volume: -28, 
                            oscillator: { type: 'triangle' }, 
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 } 
                        }).connect(this.scentPanner),
                        module1: new Tone.PluckSynth({ volume: -26, dampening: 3500, resonance: 0.96 }).connect(delay),
                        module2: new Tone.MonoSynth({ volume: -28, oscillator: { type: 'square' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5 } }).connect(chorus),
                        breakthrough: new Tone.PolySynth(Tone.AMSynth, { 
                            volume: -20, 
                            harmonicity: 1.8, 
                            modulationType: 'square',
                            envelope: { attack: 0.06, decay: 4.5, sustain: 0.15, release: 5.5 } 
                        }).connect(reverb),
                        module3_hit: new Tone.MetalSynth({ volume: -22, frequency: 150, envelope: { attack: 0.001, decay: 0.08, release: 0.05 }, harmonicity: 5, modulationIndex: 10 }).connect(filter),
                        module3_unstable: new Tone.NoiseSynth({ volume: -30, noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).connect(filter),
                        crystal_ring: new Tone.FMSynth({ volume: -24, harmonicity: 2.5, modulationIndex: 8, envelope: { attack: 0.001, decay: 0.4, sustain: 0.1, release: 0.5 } }).connect(reverb),
                        reflex_start: new Tone.MembraneSynth({ volume: -18, pitchDecay: 0.01, octaves: 1.5, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.1 } }).connect(delay),
                        reflex_cue: new Tone.FMSynth({ volume: -20, harmonicity: 0.5, modulationIndex: 5, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.02 } }).connect(filter),
                        reflex_hit: new Tone.Synth({ volume: -15, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).connect(reverb),
                        reflex_miss: new Tone.NoiseSynth({ volume: -25, noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.05 } }).connect(filter),
                        flow_pacer: new Tone.Synth({ volume: -28, oscillator: { type: 'sine' }, envelope: { attack: 1.0, decay: 0.5, sustain: 0.8, release: 1.5 } }).connect(reverb),
                    };
                    
                    this.initialized = true;
                    this.playAmbientLoop();
                    this.playAmbientPianoLayer();
                } catch(e) { console.warn('Sound init error:', e); }
            },
            
            stopAmbient() {
                if (this.ambientLoop) {
                    this.ambientLoop.dispose();
                    this.ambientLoop = null;
                }
                if (this.ambientPianoLoop) {
                    this.ambientPianoLoop.dispose();
                    this.ambientPianoLoop = null;
                }
                if (Tone.Transport.state !== 'stopped') {
                    Tone.Transport.stop();
                }
                if (this.vinylNoise) {
                    this.vinylNoise.stop();
                    this.vinylNoise.dispose();
                    this.vinylNoise = null;
                }
            },

            playAmbientLoop() {
                if (!this.ambient || this.ambientLoop) return;
                this.ambientLoop = new Tone.Loop((time) => {
                    this.ambient.triggerAttackRelease(['C3', 'Eb3', 'G3', 'Bb3'], '8m', time, 0.25);
                }, '8m');
                this.ambientLoop.start(0);
                Tone.Transport.start();
            },
            
            playAmbientPianoLayer() {
                if (!this.ambientPiano || this.ambientPianoLoop) return;
                const etherealChords = [
                    ['C4', 'E4', 'G4', 'B4'],
                    ['D4', 'F#4', 'A4', 'C5'],
                    ['G3', 'B3', 'D4', 'F#4'],
                    ['A3', 'C#4', 'E4', 'G#4']
                ];
                
                let chordIndex = 0;
                this.ambientPianoLoop = new Tone.Loop((time) => {
                    if (Math.random() > 0.65) {
                        const chord = etherealChords[chordIndex % etherealChords.length];
                        chord.forEach((note, i) => {
                            this.ambientPiano.triggerAttackRelease(note, '2m', time + i * 0.1, 0.4);
                        });
                        chordIndex++;
                    }
                }, '4m');
                this.ambientPianoLoop.start('+2m');
            },
            
            play(type, note = 'C4', velocity = 0.7) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    const now = Tone.now();
                    switch(type) {
                        case 'click': 
                            this.synths.click.triggerAttackRelease('C3', '8n', now, velocity * 0.5); 
                            break;
                        case 'hover': 
                            this.synths.hover.triggerAttackRelease('C6', '64n', now, 0.12); 
                            break;
                        case 'success': 
                            this.synths.success.triggerAttackRelease(['C5', 'Eb5', 'G5'], '2s', now, velocity * 0.6); 
                            break;
                        case 'slider': 
                            this.synths.slider.triggerAttackRelease(note, '32n', now, velocity * 0.5); 
                            break;
                        case 'breakthrough': 
                            this.synths.breakthrough.triggerAttackRelease(['C4', 'E4', 'G4', 'B4'], '3s', now, velocity * 0.7); 
                            break;
                        case 'module3_hit': 
                            this.synths.module3_hit.triggerAttackRelease('C3', '8n', now, velocity * 0.6);
                            break;
                        case 'reflex_cue': 
                            this.synths.reflex_cue.triggerAttackRelease('A5', '64n', now, 1.0);
                            break;
                        case 'reflex_hit':
                            this.synths.reflex_hit.triggerAttackRelease('G5', '16n', now, 0.9);
                            break;
                        default: 
                            if (this.synths[type]) this.synths[type].triggerAttackRelease(note, '16n', now, velocity * 0.6);
                    }
                } catch(e) { console.warn('Sound play error:', e); }
            },
            
            playScentDrag(distance, angle) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    const freq = 200 + distance * 600;
                    const note = Tone.Frequency(freq, "hz").toNote();
                    
                    const pan = Math.cos(angle);
                    if (this.scentPanner) {
                        this.scentPanner.positionX.rampTo(pan, 0.05);
                    }
                    
                    this.synths.scentDrag.frequency.rampTo(freq, 0.05);
                    if (this.synths.scentDrag.envelope.value === 0) {
                        this.synths.scentDrag.triggerAttack(note, Tone.now(), 0.5);
                    }
                } catch(e) { console.warn('Scent drag sound error:', e); }
            },
            
            stopScentDrag() {
                if (this.synths.scentDrag) {
                    this.synths.scentDrag.triggerRelease();
                }
            },
            
            start(type, note = 'C4', velocity = 0.7) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    if (this.synths[type] && this.synths[type].triggerAttack) {
                        this.synths[type].triggerAttack(note, Tone.now(), velocity * 0.6);
                    }
                } catch(e) { console.warn('Sound start error:', e); }
            },

            release(type) {
                if (!this.initialized || !this.synths[type] || !this.synths[type].triggerRelease) return;
                try { 
                    this.synths[type].triggerRelease();
                }
                catch(e) { console.warn('Sound release error:', e); }
            }
        };
        
        // ==================== I18N SYSTEM ====================
        const I18N = {
            lang: 'en',
            data: {
                en: {
                    welcome_sub: 'Personalized Olfactory-Cognitive Training',
                    btn_begin: 'BEGIN',
                    btn_continue: 'CONTINUE',
                    btn_back: '← SAVE & EXIT',
                    btn_finish: 'COMPLETE SESSION',
                    btn_restart: 'NEW SESSION',
                    btn_start_game: 'START TRAINING',
                    info_title: 'Profile',
                    info_name: 'Name',
                    info_age: 'Age',
                    info_gender: 'Gender',
                    info_status: 'Status',
                    info_male: 'Male',
                    info_female: 'Female',
                    info_nonbinary: 'Nonbinary',
                    info_prefer_not: 'Prefer not to say',
                    info_early: 'Early Stage',
                    info_moderate: 'Moderate',
                    info_control: 'Control',
                    scent_title: 'Olfactory Profile',
                    scent_desc: 'Drag outward from center to set preference',
                    scent_science: '<strong>Scientific Basis:</strong> The hippocampus (memory center) is directly connected to the olfactory bulb. Studies show <em>53% of Alzheimer\'s patients have the highest hippocampal atrophy rate</em> (Verdi et al., 2024). Olfactory training may provide neuroprotective effects by activating the hippocampal-olfactory circuit.',
                    modules_title: 'Training Modules',
                    difficulty_label: 'Simulate Patient tOC (Total Outlier Count)',
                    difficulty_desc: 'Higher tOC increases module difficulty.',
                    stat_time: 'Time',
                    stat_score: 'Score',
                    stat_progress: 'Progress',
                    results_title: 'Session Report',
                    results_scent: 'Recommended Scent Profile',
                    total_time: 'Total Time',
                    avg_score: 'Average Score',
                    modules_completed: 'Modules Completed',
                    floral_desc: 'ETHEREAL, EMOTIONAL, MEMORY\n\nDelicate petals unfolding in soft whispers. Linked to emotional warmth and nostalgic recall.\nExamples: Rose, Jasmine, Ylang-Ylang, Neroli',
                    woody_desc: 'GROUNDED, ENDURING, FOCUS\n\nDeep timber essence. Anchors attention and provides steady mental foundation.\nExamples: Cedarwood, Sandalwood, Oud, Vetiver',
                    citrus_desc: 'SHARP, VIBRANT, ALERTNESS\n\nA sudden, zesty burst used to enhance cognitive speed and refresh attention.\nExamples: Lemon, Bergamot, Grapefruit, Lime',
                    earthy_desc: 'ROOTED, CALM, PRESENCE\n\nMoss-covered stones and ancient soil. Cultivates deep presence and stability.\nExamples: Patchouli, Oakmoss, Earth, Mushroom',
                    fresh_desc: 'CRISP, CLEAR, RENEWAL\n\nCool morning air and mountain springs. Clears mental fog and stimulates clarity.\nExamples: Eucalyptus, Marine, Mint, Pine',
                    spicy_desc: 'WARM, INTENSE, STIMULATION\n\nFiery heat that awakens. Sharpens reflexes and accelerates processing.\nExamples: Cinnamon, Clove, Ginger, Black Pepper',
                    mod1_intro: 'Quantify transient neural traces',
                    mod2_intro: 'Isolate signal from noise',
                    mod3_intro: 'Decode emergent schemas',
                    mod4_intro: 'Synchronize oscillations', 
                    mod5_intro: 'Measure sensorimotor arc',
                    mod6_intro: 'Attune to visceral flow',
                    mod1_desc: 'Track ephemeral sequences as they dissolve into memory',
                    mod2_desc: 'Sustain focal attention amidst distributed interference',
                    mod3_desc: 'Recognize and stabilize evolving cognitive patterns',
                    mod4_desc: 'Align neuronal rhythms across temporal dimensions', 
                    mod5_desc: 'Execute precision inhibition under temporal constraint',
                    mod6_desc: 'Harmonize breath with fluid vortex dynamics (4-7-8)',
                    mod1_tut_title: 'Memory: Fish School Counter',
                    mod1_tut_desc: 'Watch fish swim across the screen. Count how many you see! First round: count 1 school. Later rounds: count 2 schools separately.',
                    mod2_tut_title: 'Signal',
                    mod2_tut_desc: 'A signal moves through noise. CAPTURE and HOLD it precisely with your finger/mouse until breakthrough energy builds.',
                    mod3_tut_title: 'Pattern Recognition',
                    mod3_tut_desc: 'PRESS AND HOLD (two fingers on mobile, click/press on desktop) to stabilize the core. Answer the cognitive question quickly. Errors will deduct points.',
                    mod4_tut_title: 'Frequency Wave Match',
                    mod4_tut_desc: 'Wave patterns oscillate on screen. Match your wave (black) to the target wave (red) by adjusting frequency and amplitude with the elegant sliders. Each stage presents a unique wave type.',
                    mod5_tut_title: 'Reflex: Target Practice',
                    mod5_tut_desc: 'After 3-2-1 countdown, dots will light up. Tap BLACK dots quickly for points. AVOID RED dots (they subtract points). Miss a black dot and lose points too. Stay sharp!',
                    mod6_tut_title: 'Flow: Kármán Vortex',
                    mod6_tut_desc: 'Guided 4-7-8 breathing synchronized with fluid dynamics. Inhale (4s, HOLD), Pause (7s), Exhale (8s, RELEASE). Follow the flowing patterns. Only synchronization matters.',
                    trajectory_title: '12-Month Cognitive Trajectory (Simulated)',
                    trajectory_desc: 'This simulated tracking chart is based on your current performance. Real-world application requires consistent monthly assessments over 12 months.',
                    trajectory_disclaimer: '* Statistical inference based on normative modeling, not clinical diagnosis',
                    fingerprint_title: 'Your Unique Cognitive Fingerprint',
                    fingerprint_desc: 'Each individual\'s cognitive pattern is unique. The radar chart displays your deviation across 8 cognitive domains (relative to normal range).',
                    status_stable: 'Your simulated change rate is within the healthy stable range',
                    prediction_title: '12-Month Prediction (Based on Current Trend)',
                    prediction_items: '<li><span>Memory Function:</span><span class="improve">+6-8% Improvement</span></li><li><span>Executive Function:</span><span class="stable">Stable</span></li><li><span>Overall tOC:</span><span class="stable">+2-3 Expected Growth</span></li>',
                    pattern_classification: 'Your Cognitive Pattern Classification',
                    pattern_desc_template: 'Based on your radar pattern, you are classified as <strong id="pattern-name">"Balanced Profile"</strong>. This indicates relatively balanced cognitive function across all domains.',
                    pattern_pct_template: 'Prevalence in study population: <strong id="pattern-percentage">45%</strong>',
                    pattern_recommendation: '<strong>Personalized Recommendation:</strong> Continue comprehensive cognitive training while using balanced scent combinations (e.g., Lavender + Rosemary) to maintain overall brain health.',
                    toc_risk_title: 'Your tOC Risk Score',
                    toc_risk_desc: 'Based on your current cognitive performance and tOC setting (<span id="current-toc-display"></span>), the system calculates your risk level. Continuous tracking helps detect early signs of accelerated cognitive change.',
                    legend_normal: 'Normal Range',
                    legend_mild: 'Mild Deviation (-1σ)',
                    legend_moderate: 'Moderate Deviation (-2σ)',
                },
                zh: {
                    welcome_sub: '个性化嗅觉-认知训练',
                    btn_begin: '开始',
                    btn_continue: '继续',
                    btn_back: '← 保存并退出',
                    btn_finish: '完成会话',
                    btn_restart: '新会话',
                    btn_start_game: '开始训练',
                    info_title: '个人档案',
                    info_name: '姓名',
                    info_age: '年龄',
                    info_gender: '性别',
                    info_status: '状态',
                    info_male: '男性',
                    info_female: '女性',
                    info_nonbinary: '非二元',
                    info_prefer_not: '不愿透露',
                    info_early: '早期',
                    info_moderate: '中度',
                    info_control: '可控范围内',
                    scent_title: '气味偏好档案',
                    scent_desc: '从中心向外拖动以设置偏好度',
                    scent_science: '<strong>神经科学依据：</strong>海马体（记忆中心）与嗅球直接相连。研究显示<em>53%的阿尔茨海默症患者海马体萎缩率最高</em>（Verdi et al., 2024）。嗅觉训练可能通过激活海马体-嗅觉回路提供神经保护作用。',
                    modules_title: '训练模块',
                    difficulty_label: '模拟患者tOC(总离群值计数)',
                    difficulty_desc: '更高的tOC值将增加模块难度。',
                    stat_time: '耗时',
                    stat_score: '得分',
                    stat_progress: '进度',
                    results_title: '会话报告',
                    results_scent: '推荐气味档案',
                    total_time: '总耗时',
                    avg_score: '平均得分',
                    modules_completed: '已完成模块',
                    floral_desc: '空灵、情感、记忆\n\n轻柔的花瓣在低语中绽放。与情感温暖和怀旧回忆相联系。\n例如: 玫瑰、茉莉、依兰、橙花',
                    woody_desc: '扎根、持久、专注\n\n深沉的木质本质。锚定注意力并提供稳定的心智基础。\n例如: 雪松、檀香、沉香、岩兰草',
                    citrus_desc: '锐利、活力、警觉\n\n突如其来的清新爆发,用于增强认知速度和刷新注意力。\n例如: 柠檬、佛手柑、葡萄柚、青柠',
                    earthy_desc: '根植、平静、临在\n\n苔藓覆盖的石头和古老的土壤。培养深层临在感和稳定性。\n例如: 广藿香、橡苔、泥土、蘑菇',
                    fresh_desc: '清爽、清晰、更新\n\n清晨的空气和山泉。清除思维迷雾并刺激清晰度。\n例如: 桉树、海洋、薄荷、松树',
                    spicy_desc: '温暖、强烈、刺激\n\n唤醒的炽热。磨砺反射并加速处理。\n例如: 肉桂、丁香、生姜、黑胡椒',
                    mod1_intro: '量化瞬时神经轨迹',
                    mod2_intro: '从噪声中分离信号',
                    mod3_intro: '解码涌现图式',
                    mod4_intro: '同步振荡节律',
                    mod5_intro: '测量感知运动弧',
                    mod6_intro: '调谐至本体流动',
                    mod1_desc: '追踪消散于记忆中的短暂序列',
                    mod2_desc: '在分布式干扰中维持焦点注意',
                    mod3_desc: '识别并稳定演化的认知模式',
                    mod4_desc: '跨时间维度对齐神经元节律',
                    mod5_desc: '在时间约束下执行精准抑制',
                    mod6_desc: '使呼吸与流体涡旋动力学和谐共振(4-7-8)',
                    mod1_tut_title: '记忆:鱼群计数',
                    mod1_tut_desc: '观察鱼群游过屏幕。数清你看到了几条!第一轮:数1群。后续轮次:分别数2群。',
                    mod2_tut_title: '信号',
                    mod2_tut_desc: '信号在噪声中移动。用手指/鼠标精确捕捉并按住它,直到突破能量积累完成。',
                    mod3_tut_title: '模式识别',
                    mod3_tut_desc: '按住(移动设备双指按住,桌面端点击/按住)以稳定核心。快速回答认知问题。错误将扣分。',
                    mod4_tut_title: '频率波形匹配',
                    mod4_tut_desc: '波形在屏幕上振荡。通过优雅的滑条调整频率和振幅,让你的波形(黑色)匹配目标波形(红色)。每个阶段呈现独特的波形类型。',
                    mod5_tut_title: '反射:目标练习',
                    mod5_tut_desc: '3-2-1倒计时后,点会亮起。快速点击黑色点得分。避开红色点(会扣分)。错过黑点也会扣分。保持警觉!',
                    mod6_tut_title: '流动:呼吸同步',
                    mod6_tut_desc: '引导式4-7-8呼吸与流体动力学同步。吸气(4秒,按住)、屏息(7秒)、呼气(8秒,释放)。跟随流动模式。只有同步率。',
                    trajectory_title: '12个月认知轨迹（模拟）',
                    trajectory_desc: '以下为基于您当前表现的模拟追踪图。实际应用中需要持续12个月的定期评估。',
                    trajectory_disclaimer: '* 基于规范化模型的统计推断，非临床诊断',
                    fingerprint_title: '您的独特认知指纹',
                    fingerprint_desc: '每个人的认知模式都是独特的。雷达图显示您在8个认知域的偏离程度（相对于正常范围）。',
                    status_stable: '您的模拟变化率处于健康稳定区间',
                    prediction_title: '12个月预测（基于当前趋势）',
                    prediction_items: '<li><span>记忆功能：</span><span class="improve">+6-8% 改善</span></li><li><span>执行功能：</span><span class="stable">保持稳定</span></li><li><span>整体tOC：</span><span class="stable">+2-3 预计增长</span></li>',
                    pattern_classification: '您的认知模式分类',
                    pattern_desc_template: '基于您的雷达图模式，您被归类为<strong id="pattern-name">"平衡型"</strong>。这意味着您的认知功能在各个领域相对均衡。',
                    pattern_pct_template: '在研究人群中占比：<strong id="pattern-percentage">45%</strong>',
                    pattern_recommendation: '<strong>个性化建议：</strong>继续全面的认知训练，同时使用均衡型气味组合（如薰衣草+迷迭香）以维持整体脑健康。',
                    toc_risk_title: '您的tOC风险评分',
                    toc_risk_desc: '基于您当前的认知表现和tOC设置（<span id="current-toc-display"></span>），系统计算出您的风险等级。持续追踪可帮助早期发现认知变化加速的信号。',
                    legend_normal: '正常范围',
                    legend_mild: '轻度偏离 (-1σ)',
                    legend_moderate: '中度偏离 (-2σ)',
                }
            },
            set(lang) {
                this.lang = lang;
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (this.data[lang][key]) {
                        // Use innerHTML for keys that contain HTML
                        if (key === 'scent_science' || key.includes('_html') || key.includes('_template') || key === 'pattern_recommendation' || key === 'toc_risk_desc') {
                            el.innerHTML = this.data[lang][key];
                        } else {
                            el.textContent = this.data[lang][key];
                        }
                    }
                });
                
                // Handle data-i18n-html separately
                document.querySelectorAll('[data-i18n-html]').forEach(el => {
                    const key = el.getAttribute('data-i18n-html');
                    if (this.data[lang][key]) {
                        el.innerHTML = this.data[lang][key];
                    }
                });
                
                document.querySelectorAll('#user-gender option').forEach(option => {
                    const key = option.dataset.i18n;
                    if (key) {
                        const baseText = option.value === '' ? (this.lang === 'zh' ? '选择性别' : 'Select gender') : (this.data.en[key] || '');
                        option.textContent = baseText + (this.lang === 'zh' ? ` / ${this.data.zh[key]}` : '');
                    }
                });
                document.querySelectorAll('#user-status option').forEach(option => {
                    const key = option.dataset.i18n;
                    if (key) {
                        const baseText = option.value === '' ? (this.lang === 'zh' ? '选择状态' : 'Select status') : (this.data.en[key] || '');
                        option.textContent = baseText + (this.lang === 'zh' ? ` / ${this.data.zh[key]}` : '');
                    }
                });

                if (App.state === 'MODULES') {
                    setTimeout(() => {
                        App.updateModules();
                        if (ModuleGallery.updateLanguage) ModuleGallery.updateLanguage();
                    }, 10);
                }
                if (App.state === 'SCENT') LumenScent.updateLabels();
            },
            t(key) { return this.data[this.lang][key] || key; }
        };
        
        // ==================== LUMEN SCENT SYSTEM ====================
        const LumenScent = {
            scents: [
                { 
                    id: 'floral', 
                    en: 'Floral', 
                    zh: '花香', 
                    shape: 'flower', 
                    colors: [
                        { r: 255, g: 193, b: 182 },
                        { r: 255, g: 160, b: 160 },
                        { r: 232, g: 74, b: 95 }
                    ] 
                },
                { 
                    id: 'woody', 
                    en: 'Woody', 
                    zh: '木质', 
                    shape: 'trunk', 
                    colors: [
                        { r: 139, g: 69, b: 19 },
                        { r: 131, g: 90, b: 60 },
                        { r: 44, g: 23, b: 8 }
                    ] 
                },
                { 
                    id: 'citrus', 
                    en: 'Citrus', 
                    zh: '柑橘', 
                    shape: 'burst', 
                    colors: [
                        { r: 255, g: 240, b: 100 },
                        { r: 255, g: 215, b: 0 },
                        { r: 255, g: 180, b: 0 }
                    ] 
                },
                { 
                    id: 'earthy', 
                    en: 'Earthy', 
                    zh: '土壤', 
                    shape: 'moss', 
                    colors: [
                        { r: 85, g: 107, b: 47 },
                        { r: 76, g: 92, b: 23 },
                        { r: 36, g: 47, b: 20 }
                    ] 
                },
                { 
                    id: 'fresh', 
                    en: 'Fresh', 
                    zh: '清新', 
                    shape: 'wave', 
                    colors: [
                        { r: 155, g: 183, b: 212 },
                        { r: 100, g: 140, b: 180 },
                        { r: 58, g: 78, b: 107 }
                    ] 
                },
                { 
                    id: 'spicy', 
                    en: 'Spicy', 
                    zh: '辛香', 
                    shape: 'chili', 
                    colors: [
                        { r: 178, g: 34, b: 34 },
                        { r: 124, g: 34, b: 32 },
                        { r: 95, g: 33, b: 25 }
                    ] 
                }
            ],
            values: {},
            isActive: false,
            instances: [],
            currentPage: 0,
            dragging: null,

            init() {
                this.isActive = true;
                this.scents.forEach(scent => {
                    this.values[scent.id] = 0;
                });
                
                this.instances = [];
                
                this.scents.forEach((scent, idx) => {
                    const pageEl = document.querySelector(`.scent-page[data-page="${idx}"]`);
                    if (!pageEl) return; 

                    pageEl.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = 'width: 100%; display: flex; flex-direction: column; align-items: center; flex: 1;';
                    
                    const canvasWrapper = document.createElement('div');
                    canvasWrapper.style.cssText = 'position: relative; flex-shrink: 0; margin-bottom: 1rem;';
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'lumen-canvas';
                    
                    const isMobile = window.innerWidth <= 768;
                    const size = isMobile ? Math.min(280, window.innerWidth - 40) : Math.min(350, window.innerWidth - 60);
                    canvas.width = size;
                    canvas.height = size;
                    canvasWrapper.appendChild(canvas);
                    container.appendChild(canvasWrapper);
                    
                    const label = document.createElement('div');
                    label.className = 'lumen-label';
                    label.innerHTML = `
                        <div class="lumen-name ${I18N.lang === 'zh' ? 'zh' : ''}" data-scent="${scent.id}">${scent[I18N.lang]}</div>
                        <div class="lumen-value" data-value="${scent.id}">0</div>
                        <p class="lumen-instruction">
                            ${I18N.lang === 'en' ? 'Drag outward from center' : '从中心向外拖动'}
                        </p>
                    `;
                    container.appendChild(label);
                    
                    const introBox = document.createElement('div');
                    introBox.className = `scent-intro-box ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    introBox.dataset.scent = scent.id;
                    const key = `${scent.id}_desc`;
                    introBox.textContent = I18N.t(key);
                    container.appendChild(introBox);
                    
                    // Add science note below intro box
                    const scienceNote = document.createElement('div');
                    scienceNote.className = `scent-science-note ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    scienceNote.innerHTML = I18N.lang === 'en' 
                        ? '<strong>Scientific Basis:</strong> The hippocampus (memory center) is directly connected to the olfactory bulb. Studies show <em>53% of Alzheimer\'s patients have the highest hippocampal atrophy rate</em> (Verdi et al., 2024). Olfactory training may provide neuroprotective effects by activating the hippocampal-olfactory circuit.'
                        : '<strong>神经科学依据：</strong>海马体（记忆中心）与嗅球直接相连。研究显示<em>53%的阿尔茨海默症患者海马体萎缩率最高</em>（Verdi et al., 2024）。嗅觉训练可能通过激活海马体-嗅觉回路提供神经保护作用。';
                    container.appendChild(scienceNote);
                    
                    pageEl.appendChild(container);
                    
                    const instance = new LumenOrganicParticles(canvas, scent, this);
                    this.instances.push(instance);
                    
                    this.addRadialInteraction(canvas, scent.id, instance);
                });
                
                this.updateLabels();
                ResourceManager.register('lumenscent', this);
                
                // Add touch swipe support for mobile
                this.addTouchSwipeSupport();
            },

            update(deltaTime = 16.6) {
                if (App.state !== 'SCENT') return;
                this.instances.forEach(inst => inst.update(deltaTime));
            },
            
            addTouchSwipeSupport() {
                const pagesContainer = document.getElementById('scent-pages');
                if (!pagesContainer) return;
                
                let touchStartX = 0;
                let touchStartY = 0;
                let touchEndX = 0;
                let touchEndY = 0;
                let isSwiping = false;
                
                const handleTouchStart = (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    isSwiping = false;
                };
                
                const handleTouchMove = (e) => {
                    if (!e.touches[0]) return;
                    touchEndX = e.touches[0].clientX;
                    touchEndY = e.touches[0].clientY;
                    
                    const deltaX = Math.abs(touchEndX - touchStartX);
                    const deltaY = Math.abs(touchEndY - touchStartY);
                    
                    // If horizontal swipe is dominant, prevent default to enable swipe
                    if (deltaX > deltaY && deltaX > 10) {
                        isSwiping = true;
                    }
                };
                
                const handleTouchEnd = (e) => {
                    if (!isSwiping) return;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = Math.abs(touchEndY - touchStartY);
                    
                    // Only trigger if horizontal movement is significant and greater than vertical
                    if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > deltaY) {
                        if (deltaX > 0) {
                            // Swipe right - go to previous page
                            this.prevPage();
                        } else {
                            // Swipe left - go to next page
                            this.nextPage();
                        }
                    }
                    
                    isSwiping = false;
                };
                
                pagesContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
                pagesContainer.addEventListener('touchmove', handleTouchMove, { passive: true });
                pagesContainer.addEventListener('touchend', handleTouchEnd, { passive: true });
                
                // Store listeners for cleanup
                this.touchListeners = {
                    touchStart: handleTouchStart,
                    touchMove: handleTouchMove,
                    touchEnd: handleTouchEnd,
                    element: pagesContainer
                };
            },

            addRadialInteraction(canvas, scentId, instance) {
                const getPointer = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
                    if (!clientX || !clientY) return null;
                    
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;
                    return { x, y };
                };
                
                const onStart = (e) => {
                    if (!this.isActive) return;
                    this.dragging = scentId;
                    instance.isDragging = true;
                    e.preventDefault();
                };
                
                const onMove = PerformanceUtils.throttle((e) => {
                    if (this.dragging !== scentId || !this.isActive) return;
                    
                    const pos = getPointer(e);
                    if (!pos) return;
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const dx = pos.x - centerX;
                    const dy = pos.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = Math.min(centerX, centerY) * 0.8;
                    
                    const value = Math.min(100, Math.max(0, (dist / maxDist) * 100));
                    this.values[scentId] = Math.round(value);
                    
                    const valueEl = document.querySelector(`[data-value="${scentId}"]`);
                    if (valueEl) valueEl.textContent = this.values[scentId];
                    
                    instance.targetIntensity = this.values[scentId] / 100;
                    instance.dragAngle = Math.atan2(dy, dx);
                    instance.dragDist = dist / maxDist;
                    
                    Sound.playScentDrag(instance.dragDist, instance.dragAngle);
                    
                    e.preventDefault();
                }, 16);
                
                const onEnd = () => {
                    if (this.dragging === scentId) {
                        this.dragging = null;
                        instance.isDragging = false;
                        Sound.stopScentDrag();
                    }
                };
                
                // Store listeners on instance for cleanup
                instance.listeners = { onStart, onMove, onEnd };
                
                canvas.addEventListener('mousedown', onStart);
                canvas.addEventListener('touchstart', onStart, { passive: false });
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('touchmove', onMove, { passive: false });
                
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchend', onEnd);
                
                canvas.addEventListener('contextmenu', e => e.preventDefault());
            },
            
            prevPage() {
                if (this.currentPage > 0) {
                    this.goToPage(this.currentPage - 1);
                    Sound.play('click');
                }
            },
            
            nextPage() {
                if (this.currentPage < 5) {
                    this.goToPage(this.currentPage + 1);
                    Sound.play('click');
                }
            },
            
            goToPage(page) {
                const pages = document.querySelectorAll('.scent-page');
                const dots = document.querySelectorAll('.page-dot');
                
                pages[this.currentPage].classList.remove('active');
                pages[this.currentPage].classList.add('prev');
                
                pages[page].classList.remove('prev');
                pages[page].classList.add('active');
                
                dots[this.currentPage].classList.remove('active');
                dots[page].classList.add('active');
                
                this.currentPage = page;
                
                document.getElementById('scent-prev').style.opacity = page === 0 ? '0.3' : '1';
                document.getElementById('scent-next').style.opacity = page === 5 ? '0.3' : '1';
                
                this.updateLabels();
            },
            
            updateLabels() {
                document.querySelectorAll('.scent-intro-box').forEach(introEl => {
                    const scentId = introEl.dataset.scent;
                    if (scentId) {
                        introEl.classList.toggle('zh', I18N.lang === 'zh');
                        const key = `${scentId}_desc`;
                        introEl.textContent = I18N.t(key);
                    }
                });
                
                // Update science notes
                document.querySelectorAll('.scent-science-note').forEach(scienceEl => {
                    scienceEl.classList.toggle('zh', I18N.lang === 'zh');
                    scienceEl.innerHTML = I18N.lang === 'en' 
                        ? '<strong>Scientific Basis:</strong> The hippocampus (memory center) is directly connected to the olfactory bulb. Studies show <em>53% of Alzheimer\'s patients have the highest hippocampal atrophy rate</em> (Verdi et al., 2024). Olfactory training may provide neuroprotective effects by activating the hippocampal-olfactory circuit.'
                        : '<strong>神经科学依据：</strong>海马体（记忆中心）与嗅球直接相连。研究显示<em>53%的阿尔茨海默症患者海马体萎缩率最高</em>（Verdi et al., 2024）。嗅觉训练可能通过激活海马体-嗅觉回路提供神经保护作用。';
                });

                this.scents.forEach(scent => {
                    const el = document.querySelector(`[data-scent="${scent.id}"]`);
                    if (el && el.classList.contains('lumen-name')) {
                        el.textContent = scent[I18N.lang];
                        el.className = `lumen-name ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    }
                });
                
                document.querySelectorAll('.lumen-instruction').forEach(instr => {
                    instr.textContent = I18N.lang === 'en' ? 'Drag outward from center' : '从中心向外拖动';
                });
            },
            
            cleanup() {
                console.log('🧹 Cleaning up LumenScent...');
                this.isActive = false;
                
                this.instances.forEach(instance => {
                    if (instance.listeners) {
                        const canvas = instance.canvas;
                        const { onStart, onMove, onEnd } = instance.listeners;
                        
                        if (canvas && onStart) {
                            canvas.removeEventListener('mousedown', onStart);
                            canvas.removeEventListener('touchstart', onStart);
                        }
                        if (onMove) {
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('touchmove', onMove);
                        }
                        if (onEnd) {
                            document.removeEventListener('mouseup', onEnd);
                            document.removeEventListener('touchend', onEnd);
                        }
                    }
                });
                
                // Clean up touch swipe listeners
                if (this.touchListeners) {
                    const { element, touchStart, touchMove, touchEnd } = this.touchListeners;
                    if (element) {
                        element.removeEventListener('touchstart', touchStart);
                        element.removeEventListener('touchmove', touchMove);
                        element.removeEventListener('touchend', touchEnd);
                    }
                    this.touchListeners = null;
                }
                
                this.instances = [];
                this.dragging = null;
                console.log('✓ LumenScent cleaned up');
            }
        };
        
        // ==================== MODULE GALLERY (SWIPEABLE) ====================
        const ModuleGallery = {
            currentPage: 0,
            touchListeners: null,
            
            init() {
                console.log('🎨 Initializing Module Gallery...');
                
                // Determine which page to show based on App.current
                let initialPage = 0;
                if (App.current) {
                    const moduleIndex = parseInt(App.current) - 1; // Module IDs are 1-6, pages are 0-5
                    if (moduleIndex >= 0 && moduleIndex <= 5) {
                        initialPage = moduleIndex;
                        console.log(`📌 Returning to module ${App.current} (page ${initialPage})`);
                    }
                }
                
                this.currentPage = initialPage;
                this.renderPages();
                this.setupNavigation();
                this.addTouchSwipeSupport();
                this.updateNavButtons();
                
                // Jump to the correct page after rendering
                if (initialPage > 0) {
                    setTimeout(() => this.goToPage(initialPage), 50);
                }
            },
            
            renderPages() {
                const container = document.getElementById('module-pages-container');
                if (!container) return;
                
                container.innerHTML = '';
                const lang = I18N.lang;
                
                Object.keys(MODULES).forEach((id, index) => {
                    const mod = MODULES[id];
                    const isCompleted = App.completed.has(id);
                    
                    const page = document.createElement('div');
                    page.className = `module-page ${index === this.currentPage ? 'active' : ''}`;
                    page.dataset.page = index;
                    
                    const cover = document.createElement('div');
                    cover.className = 'module-cover';
                    cover.dataset.moduleId = id;
                    
                    // Background visual element
                    const bg = document.createElement('div');
                    bg.className = 'module-cover-bg';
                    bg.innerHTML = this.getModuleVisual(id);
                    cover.appendChild(bg);
                    
                    // Content
                    const content = document.createElement('div');
                    content.className = 'module-cover-content';
                    
                    // Status badge
                    if (isCompleted) {
                        const status = document.createElement('div');
                        status.className = 'module-status';
                        status.textContent = lang === 'en' ? '✓ COMPLETED' : '✓ 已完成';
                        content.appendChild(status);
                    } else {
                        const status = document.createElement('div');
                        status.className = 'module-status incomplete';
                        status.textContent = lang === 'en' ? 'NOT STARTED' : '未开始';
                        content.appendChild(status);
                    }
                    
                    // Title
                    const title = document.createElement('h3');
                    title.className = `module-cover-title serif ${lang === 'zh' ? 'zh' : ''}`;
                    title.textContent = mod.title[lang];
                    content.appendChild(title);
                    
                    // Subtitle
                    const subtitle = document.createElement('div');
                    subtitle.className = 'module-cover-subtitle';
                    subtitle.textContent = mod.subtitle[lang];
                    content.appendChild(subtitle);
                    
                    // Description
                    const description = document.createElement('div');
                    description.className = 'module-cover-description';
                    
                    const descText = document.createElement('p');
                    descText.className = `module-cover-text ${lang === 'zh' ? 'zh' : ''}`;
                    descText.textContent = mod.fullDesc[lang];
                    description.appendChild(descText);
                    
                    const science = document.createElement('div');
                    science.className = `module-cover-science ${lang === 'zh' ? 'zh' : ''}`;
                    science.innerHTML = mod.science[lang];
                    description.appendChild(science);
                    
                    content.appendChild(description);
                    
                    // Actions
                    const actions = document.createElement('div');
                    actions.className = 'module-cover-actions';
                    
                    const startBtn = document.createElement('button');
                    startBtn.className = 'btn accent';
                    startBtn.textContent = lang === 'en' ? 'START' : '开始训练';
                    startBtn.onclick = () => {
                        Sound.play('click');
                        App.startModule(id);  // 使用正确的方法名
                    };
                    actions.appendChild(startBtn);
                    
                    content.appendChild(actions);
                    cover.appendChild(content);
                    page.appendChild(cover);
                    container.appendChild(page);
                });
            },
            
            getModuleVisual(id) {
                // Create unique visual patterns for each module
                const visuals = {
                    '1': `<svg width="100%" height="100%" style="opacity: 0.15;">
                        <defs>
                            <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:rgb(255,193,182);stop-opacity:1" />
                                <stop offset="100%" style="stop-color:rgb(255,160,160);stop-opacity:0" />
                            </linearGradient>
                        </defs>
                        ${Array.from({length: 8}, (_, i) => `
                            <ellipse cx="${20 + i * 12}%" cy="${30 + Math.sin(i) * 20}%" rx="30" ry="15" 
                                fill="url(#grad1)" opacity="${0.3 + Math.random() * 0.3}"/>
                        `).join('')}
                    </svg>`,
                    '2': `<svg width="100%" height="100%" style="opacity: 0.12;">
                        ${Array.from({length: 150}, (_, i) => `
                            <circle cx="${Math.random() * 100}%" cy="${Math.random() * 100}%" 
                                r="${1 + Math.random() * 2}" fill="rgba(42, 42, 42, ${0.1 + Math.random() * 0.2})"/>
                        `).join('')}
                        <circle cx="50%" cy="50%" r="40" fill="none" stroke="rgba(192, 38, 37, 0.3)" stroke-width="2"/>
                    </svg>`,
                    '3': `<svg width="100%" height="100%" style="opacity: 0.1;">
                        <defs>
                            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
                                <rect width="40" height="40" fill="none" stroke="rgba(42,42,42,0.1)" stroke-width="0.5"/>
                            </pattern>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#grid)"/>
                        <polygon points="50,20 80,80 20,80" fill="rgba(192, 38, 37, 0.08)"/>
                    </svg>`,
                    '4': `<svg width="100%" height="100%" style="opacity: 0.12;">
                        ${Array.from({length: 5}, (_, i) => `
                            <path d="M 0,${50 + i * 15} Q 25,${30 + i * 15} 50,${50 + i * 15} T 100,${50 + i * 15}" 
                                fill="none" stroke="rgba(192, 38, 37, ${0.1 + i * 0.05})" stroke-width="2"/>
                        `).join('')}
                    </svg>`,
                    '5': `<svg width="100%" height="100%" style="opacity: 0.1;">
                        ${Array.from({length: 12}, (_, i) => {
                            const angle = (i / 12) * Math.PI * 2;
                            const x = 50 + Math.cos(angle) * 30;
                            const y = 50 + Math.sin(angle) * 30;
                            return `<line x1="50%" y1="50%" x2="${x}%" y2="${y}%" 
                                stroke="rgba(42, 42, 42, 0.15)" stroke-width="1"/>`;
                        }).join('')}
                        <circle cx="50%" cy="50%" r="5" fill="rgba(192, 38, 37, 0.3)"/>
                    </svg>`,
                    '6': `<svg width="100%" height="100%" style="opacity: 0.1;">
                        <defs>
                            <radialGradient id="vortex">
                                <stop offset="0%" stop-color="rgba(100, 140, 180, 0.2)"/>
                                <stop offset="100%" stop-color="rgba(155, 183, 212, 0)"/>
                            </radialGradient>
                        </defs>
                        ${Array.from({length: 6}, (_, i) => `
                            <ellipse cx="50%" cy="50%" rx="${20 + i * 10}" ry="${15 + i * 8}" 
                                fill="none" stroke="url(#vortex)" stroke-width="2" 
                                transform="rotate(${i * 30} 50 50)"/>
                        `).join('')}
                    </svg>`
                };
                return visuals[id] || '';
            },
            
            setupNavigation() {
                const prevBtn = document.getElementById('module-prev');
                const nextBtn = document.getElementById('module-next');
                
                if (!prevBtn || !nextBtn) {
                    console.error('❌ Navigation buttons not found!');
                    return;
                }
                
                // Remove old listeners if any
                const newPrevBtn = prevBtn.cloneNode(true);
                const newNextBtn = nextBtn.cloneNode(true);
                prevBtn.replaceWith(newPrevBtn);
                nextBtn.replaceWith(newNextBtn);
                
                // Add fresh listeners
                newPrevBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('⬅️ Prev button clicked');
                    this.prevPage();
                });
                
                newNextBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('➡️ Next button clicked');
                    this.nextPage();
                });
                
                document.querySelectorAll('.module-page-dot').forEach(dot => {
                    dot.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const page = parseInt(dot.dataset.page);
                        console.log(`🔘 Dot ${page} clicked`);
                        this.goToPage(page);
                        Sound.play('click');
                    });
                });
                
                console.log('✅ Navigation setup complete');
            },
            
            prevPage() {
                console.log(`⬅️ Module prevPage called, current: ${this.currentPage}`);
                if (this.currentPage > 0) {
                    this.goToPage(this.currentPage - 1);
                    Sound.play('click');
                } else {
                    console.log('Already at first module');
                }
            },
            
            nextPage() {
                console.log(`➡️ Module nextPage called, current: ${this.currentPage}`);
                if (this.currentPage < 5) {
                    this.goToPage(this.currentPage + 1);
                    Sound.play('click');
                } else {
                    console.log('Already at last module');
                }
            },
            
            goToPage(page) {
                console.log(`📍 Module goToPage: ${this.currentPage} → ${page}`);
                const pages = document.querySelectorAll('.module-page');
                const dots = document.querySelectorAll('.module-page-dot');
                
                pages[this.currentPage].classList.remove('active');
                pages[this.currentPage].classList.add('prev');
                
                pages[page].classList.remove('prev');
                pages[page].classList.add('active');
                
                dots[this.currentPage].classList.remove('active');
                dots[page].classList.add('active');
                
                this.currentPage = page;
                this.updateNavButtons();
            },
            
            updateNavButtons() {
                const prevBtn = document.getElementById('module-prev');
                const nextBtn = document.getElementById('module-next');
                const dots = document.querySelectorAll('.module-page-dot');
                
                if (prevBtn && nextBtn) {
                    prevBtn.disabled = this.currentPage === 0;
                    nextBtn.disabled = this.currentPage === 5;
                }
                
                // Update dots active state
                dots.forEach((dot, index) => {
                    if (index === this.currentPage) {
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                    }
                });
            },
            
            addTouchSwipeSupport() {
                const container = document.getElementById('module-pages-container');
                if (!container) return;
                
                let touchStartX = 0;
                let touchEndX = 0;
                
                const handleTouchStart = (e) => {
                    touchStartX = e.touches[0].clientX;
                };
                
                const handleTouchEnd = (e) => {
                    touchEndX = e.changedTouches[0].clientX;
                    const deltaX = touchEndX - touchStartX;
                    
                    if (Math.abs(deltaX) > 50) {
                        if (deltaX > 0) {
                            this.prevPage();
                        } else {
                            this.nextPage();
                        }
                    }
                };
                
                container.addEventListener('touchstart', handleTouchStart, { passive: true });
                container.addEventListener('touchend', handleTouchEnd, { passive: true });
                
                this.touchListeners = {
                    touchStart: handleTouchStart,
                    touchEnd: handleTouchEnd,
                    element: container
                };
            },
            
            updateLanguage() {
                this.renderPages();
                this.setupNavigation();
                this.goToPage(this.currentPage);
            },
            
            cleanup() {
                if (this.touchListeners) {
                    const { element, touchStart, touchEnd } = this.touchListeners;
                    if (element) {
                        element.removeEventListener('touchstart', touchStart);
                        element.removeEventListener('touchend', touchEnd);
                    }
                    this.touchListeners = null;
                }
            }
        };
        
        // ==================== LUMEN ORGANIC PARTICLES ====================
        class LumenOrganicParticles {
            constructor(canvas, scent, parent) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: false });
                this.scent = scent;
                this.parent = parent;
                this.particles = [];
                this.time = 0;
                this.intensity = 0;
                this.targetIntensity = 0;
                this.isDragging = false;
                this.dragAngle = 0;
                this.dragDist = 0;
                this.listeners = null;
                
                // Adaptive particle count for scent visualization
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const numParticles = isMobile ? 1000 : 2000;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let i = 0; i < numParticles; i++) {
                    const layer = Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    
                    let radius, distribution, sizeBase;
                    
                    switch(scent.shape) {
                        case 'flower':
                            const petalIndex = Math.floor(Math.random() * 6);
                            const petalAngle = (petalIndex / 6) * Math.PI * 2;
                            const petalOffset = Math.sin((angle - petalAngle) * 6) * 0.4 + 0.6;
                            radius = Math.pow(Math.random(), 0.4) * 90 * petalOffset;
                            distribution = Math.sin(angle * 6) * 0.4 + 0.8;
                            sizeBase = 1.8;
                            break;
                        case 'trunk':
                            const grainLayer = Math.floor(Math.random() * 15);
                            const grainNoise = (Math.sin(angle * 20 + grainLayer * 0.5) + Math.cos(angle * 15)) * 0.15;
                            radius = (grainLayer / 15) * 80 + grainNoise * 10 + Math.random() * 4;
                            distribution = Math.abs(Math.sin(angle * 18 + grainLayer * 0.3)) * 0.3 + 0.75;
                            sizeBase = 1.4;
                            break;
                        case 'burst':
                            const burstRing = Math.floor(Math.random() * 8);
                            radius = Math.pow(Math.random(), 0.25) * 95 * (0.7 + burstRing / 16);
                            distribution = 1;
                            sizeBase = 1.6;
                            break;
                        case 'moss':
                            const mossCluster = Math.sin(angle * 7 + Math.random() * 3) * 0.3;
                            radius = Math.pow(Math.random(), 0.8) * 75 + mossCluster * 15;
                            distribution = (Math.sin(angle * 6) + Math.cos(angle * 9)) * 0.25 + 0.7;
                            sizeBase = 2.2;
                            break;
                        case 'wave':
                            const waveLayer = Math.floor(Math.random() * 8);
                            radius = Math.pow(Math.random(), 0.65) * 65 * (0.5 + waveLayer / 16);
                            distribution = Math.abs(Math.cos(angle * 5 + Math.sin(angle * 2) * 2)) * 0.35 + 0.7;
                            sizeBase = 1.4;
                            break;
                        case 'chili':
                            const spiceIntensity = Math.pow(Math.random(), 0.5);
                            radius = spiceIntensity * 80;
                            distribution = Math.pow(Math.abs(Math.sin(angle * 10)), 1.5) * 0.6 + 0.5;
                            sizeBase = 1.3;
                            break;
                        default:
                            radius = Math.pow(Math.random(), 0.6) * 70;
                            distribution = 1;
                            sizeBase = 2.0;
                    }
                    
                    radius *= distribution;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    this.particles.push({
                        baseX: x,
                        baseY: y,
                        x: x,
                        y: y,
                        angle: angle,
                        radius: radius,
                        size: Math.random() * sizeBase + 0.8,
                        speedX: (Math.random() - 0.5) * 0.2,
                        speedY: (Math.random() - 0.5) * 0.2,
                        breathPhase: Math.random() * Math.PI * 2,
                        layer: layer,
                        energy: Math.random(),
                        noiseOffset: Math.random() * 100
                    });
                }
            }
            
            update(deltaTime = 16.6) {
                this.time += deltaTime / 1000;
                
                const diff = this.targetIntensity - this.intensity;
                this.intensity += diff * 0.12;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                const centerX = w / 2;
                const centerY = h / 2;
                
                ctx.fillStyle = 'rgba(245, 245, 240, 0.95)';
                ctx.fillRect(0, 0, w, h);
                
                const colors = this.scent.colors;
                
                const globalBreath = Math.sin(this.time * 0.5) * 0.5 + 0.5;
                
                this.particles.forEach(p => {
                    const breathe = Math.sin(this.time * 0.7 + p.breathPhase) * 0.5 + 0.5;
                    const breathScale = 1 + (breathe * 0.1 + globalBreath * 0.05);
                    
                    const maxExpansion = this.scent.shape === 'wave' ? 1.8 : 2.5;
                    const expansion = this.intensity * maxExpansion;
                    
                    let targetX = centerX + (p.baseX - centerX) * (1 + expansion) * breathScale;
                    let targetY = centerY + (p.baseY - centerY) * (1 + expansion) * breathScale;
                    
                    if (this.isDragging) {
                        const dragInfluence = this.intensity * 0.6;
                        const particleAngleToDrag = Math.atan2(p.baseY - centerY, p.baseX - centerX);
                        const angleDiff = Math.abs(particleAngleToDrag - this.dragAngle);
                        const angleProximity = Math.cos(angleDiff);
                        
                        const dragForce = dragInfluence * angleProximity * (1 - p.layer * 0.5);
                        targetX += Math.cos(this.dragAngle) * this.dragDist * dragForce * 180;
                        targetY += Math.sin(this.dragAngle) * this.dragDist * dragForce * 180;
                    }
                    
                    p.x += (targetX - p.x) * 0.2 + p.speedX * (1 - this.intensity * 0.7);
                    p.y += (targetY - p.y) * 0.2 + p.speedY * (1 - this.intensity * 0.7);
                    
                    let r, g, b;
                    const energyBoost = p.energy * 0.2;
                    
                    if (this.intensity < 0.5) {
                        const t = this.intensity / 0.5;
                        r = colors[0].r + (colors[1].r - colors[0].r) * t;
                        g = colors[0].g + (colors[1].g - colors[0].g) * t;
                        b = colors[0].b + (colors[1].b - colors[0].b) * t;
                    } else {
                        const t = (this.intensity - 0.5) / 0.5;
                        r = colors[1].r + (colors[2].r - colors[1].r) * t;
                        g = colors[1].g + (colors[2].g - colors[1].g) * t;
                        b = colors[1].b + (colors[2].b - colors[1].b) * t;
                    }
                    
                    r = Math.min(255, r + energyBoost * 30);
                    g = Math.min(255, g + energyBoost * 25);
                    b = Math.min(255, b + energyBoost * 20);
                    
                    const baseSize = p.size * (0.8 + this.intensity * 2.0);
                    const size = baseSize * (1 + breathe * 0.3) * (0.7 + p.layer * 0.6);
                    
                    const baseAlpha = 0.2 + this.intensity * 0.85;
                    const alpha = baseAlpha * (0.6 + p.layer * 0.7);
                    
                    ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (this.intensity > 0.4) {
                        const glowAlpha = (this.intensity - 0.4) * 0.3 * alpha;
                        ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${glowAlpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (this.intensity > 0.75) {
                        const outerGlow = (this.intensity - 0.75) * 0.2;
                        ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${outerGlow})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size * 7, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if (this.intensity > 0.7) {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 200);
                    const c = colors[Math.min(2, Math.floor(this.intensity * 3))];
                    const bloomIntensity = (this.intensity - 0.7) * 0.5;
                    gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, ${bloomIntensity})`);
                    gradient.addColorStop(0.5, `rgba(${c.r}, ${c.g}, ${c.b}, ${bloomIntensity * 0.3})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                }
            }
        }
        
        // ==================== APP CORE ====================
        const App = {
            state: 'WELCOME',
            patient: {},
            scents: {},
            modules: {},
            completed: new Set(),
            current: null,
            tOC: 20,
            isFirstSession: true,  // 跟踪是否是第一次会话
            hasCompletedSession: false,  // 跟踪是否完成过会话
            lastSessionTOC: 20,  // 保存上次会话的tOC值
            
            screens: {
                WELCOME: 'welcome-screen',
                INFO: 'info-screen', 
                SCENT: 'scent-screen',
                MODULES: 'module-selection-screen',
                GAME: 'game-screen',
                RESULTS: 'results-screen'
            },

            resetAllResources() {
                console.log('🔄 Resetting all resources...');
                ResourceManager.cleanupAll();
            },
            
            setState(s) {
                console.log(`📍 State change: ${this.state} → ${s}`);
                
                // Clean up previous state resources
                if (this.state === 'SCENT') {
                    ResourceManager.unregister('lumenscent');
                }
                if (this.state === 'MODULES') {
                    if (ModuleGallery.cleanup) ModuleGallery.cleanup();
                }
                if (this.state === 'GAME') {
                    ResourceManager.unregister('gamemodule');
                }
                
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                document.getElementById(this.screens[s]).classList.add('active');
                this.state = s;
                
                document.getElementById('crystal-container').style.display = 'none';
                document.getElementById('reflex-canvas').style.display = 'none';
                document.getElementById('mod4-canvas').style.display = 'none';
                
                if (s === 'GAME') {
                    document.getElementById('game-ui').classList.add('active');
                    document.getElementById('game-stats').classList.add('active');
                    document.getElementById('back-btn').classList.add('active');
                } else {
                    document.getElementById('game-ui').classList.remove('active');
                    document.getElementById('game-stats').classList.remove('active');
                    document.getElementById('back-btn').classList.remove('active');
                }
                
                if (s === 'SCENT') setTimeout(() => LumenScent.init(), 100);
                if (s === 'MODULES') {
                    setTimeout(() => {
                        ModuleGallery.init();  // Initialize new gallery system
                        this.updateModules();
                        // 根据会话状态显示或隐藏tOC控制
                        const difficultyControl = document.querySelector('.difficulty-panel');
                        if (this.isFirstSession) {
                            // 第一次会话：隐藏tOC控制
                            if (difficultyControl) difficultyControl.style.display = 'none';
                        } else {
                            // 后续会话：显示tOC控制并设置上次的值
                            if (difficultyControl) difficultyControl.style.display = 'block';
                            if (this.hasCompletedSession && this.lastSessionTOC) {
                                this.tOC = this.lastSessionTOC;
                                document.getElementById('toc-slider').value = this.tOC;
                                document.getElementById('toc-value').textContent = this.tOC;
                            }
                        }
                    }, 10);
                }
                
                Visual.setScene(s);
            },
            
            startModule(id) {
                this.current = id;
                this.setState('GAME');
                
                setTimeout(() => {
                    GameEngine.showTutorial(id);
                }, 100);
            },
            
            completeModule(id, data) {
                // 只保存数据，不自动跳转
                this.completed.add(id);
                this.modules[id] = data;
                Sound.play('success');
                // 不再自动跳转到模块列表
                // this.setState('MODULES');  // 移除自动跳转
                this.updateModules();
                console.log(`✓ Module ${id} data saved (no auto-exit)`);
            },
            
            updateModules() {
                const grid = document.getElementById('module-gallery');
                grid.innerHTML = '';
                
                Object.entries(MODULES).forEach(([id, m]) => {
                    const cell = document.createElement('div');
                    cell.className = 'module-cell';
                    if (this.completed.has(id)) cell.classList.add('completed');
                    
                    const lang = I18N.lang;
                    cell.innerHTML = `
                        <h3 class="${lang === 'zh' ? 'zh' : 'serif'}">${m.title[lang]}</h3>
                        <p class="subtitle">${m.subtitle[lang]}</p>
                        <p class="description">${m.desc[lang]}</p>
                    `;
                    
                    cell.addEventListener('mouseenter', () => Sound.play('hover'));
                    cell.addEventListener('click', () => {
                        Sound.play('click');
                        this.startModule(id);
                    });
                    grid.appendChild(cell);
                });
            },
            
            finish() {
                if (this.completed.size === 0) return;
                
                // 保存当前会话的tOC值
                this.lastSessionTOC = this.tOC;
                this.hasCompletedSession = true;
                this.isFirstSession = false;
                
                Sound.play('success');
                this.setState('RESULTS');
                setTimeout(() => this.showResults(), 100);
            },
            
            drawWheel() {
                const container = document.getElementById('scent-wheel');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                const size = Math.min(400, container.clientWidth);
                canvas.width = size;
                canvas.height = size;
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                const cx = size / 2, cy = size / 2, r = size * 0.32;
                
                for (let i = 1; i <= 4; i++) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r * (i / 4), 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(192, 38, 37, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                const cats = Object.keys(this.scents);
                const step = (Math.PI * 2) / cats.length;
                
                ctx.beginPath();
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const val = this.scents[cat] / 100;
                    const x = cx + Math.cos(angle) * r * val;
                    const y = cy + Math.sin(angle) * r * val;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fillStyle = 'rgba(192, 38, 37, 0.15)';
                ctx.fill();
                ctx.strokeStyle = '#c02625';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                
                ctx.strokeStyle = 'rgba(192, 38, 37, 0.15)';
                ctx.lineWidth = 1;
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r);
                    ctx.stroke();
                });
                
                ctx.fillStyle = '#c02625';
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const val = this.scents[cat] / 100;
                    const x = cx + Math.cos(angle) * r * val;
                    const y = cy + Math.sin(angle) * r * val;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.fillStyle = '#2a2a2a';
                ctx.font = '11px Inter';
                ctx.textAlign = 'center';
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const labelDist = r + 30;
                    const x = cx + Math.cos(angle) * labelDist;
                    const y = cy + Math.sin(angle) * labelDist + 4;
                    ctx.fillText(cat.toUpperCase(), x, y);
                });
            },

            drawReportVisualization() {
                const data = Object.entries(this.modules).map(([id, d]) => {
                    let normalizedScore = d.score;
                    if (id === '5' && d.score > 0) { 
                        normalizedScore = Math.min(100, Math.max(0, 100 - (d.score - 200) / 3));
                    }
                    return {
                        module: MODULES[id].title[I18N.lang],
                        score: normalizedScore,
                        rawScore: d.score,
                        id: id 
                    };
                });

                const container = document.getElementById('report-visualization');
                container.innerHTML = '';

                const margin = { top: 20, right: 20, bottom: 60, left: 40 };
                const width = container.clientWidth - margin.left - margin.right;
                const height = container.clientHeight - margin.top - margin.bottom;

                if (width <= 0 || height <= 0) return;

                const svg = d3.select(container)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .domain(data.map(d => d.module))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);
                
                const colorScale = d3.scaleSequential(d3.interpolateInferno).domain([0, 100]);

                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                        .style("font-size", "10px")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");

                svg.append("g")
                    .call(d3.axisLeft(y).tickFormat(d => `${d}%`))
                    .selectAll("text")
                    .style("fill", "#2a2a2a");

                svg.selectAll(".bar")
                    .data(data)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.module))
                    .attr("y", d => y(d.score))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.score))
                    .attr("fill", d => colorScale(d.score))
                    .on("mouseover", function(event, d) {
                        d3.select(this).attr("opacity", 0.8);
                        
                        const tooltipText = d.id === '5' ? `${Math.round(d.rawScore)} ms RT` : `${Math.round(d.score)}% Eff.`;
                        
                        svg.append("text")
                            .attr("id", "tooltip")
                            .attr("x", x(d.module) + x.bandwidth() / 2)
                            .attr("y", y(d.score) - 5)
                            .attr("text-anchor", "middle")
                            .style("font-size", "12px")
                            .style("fill", "#c02625")
                            .text(tooltipText);
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("opacity", 1.0);
                        d3.select("#tooltip").remove();
                    });
            },

            showResults() {
                const summary = document.getElementById('results-summary');
                summary.innerHTML = '';
                
                const totalTime = Object.values(this.modules).reduce((sum, d) => sum + (d.time || 0), 0);
                const avgScore = Object.values(this.modules).reduce((sum, d) => sum + (d.score || 0), 0) / this.completed.size;
                
                const summaryData = [
                    { key: 'modules_completed', value: this.completed.size },
                    { key: 'total_time', value: Math.round(totalTime) + 's' },
                    { key: 'avg_score', value: this.completed.has('5') ? 'N/A*' : Math.round(avgScore) }
                ];
                
                summaryData.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'summary-item';
                    div.innerHTML = `
                        <h4>${I18N.t(item.key)}</h4>
                        <div class="value">${item.value}</div>
                    `;
                    summary.appendChild(div);
                });
                
                const details = document.getElementById('results-details');
                details.innerHTML = '';
                
                Object.entries(this.modules).forEach(([id, data]) => {
                    const row = document.createElement('div');
                    row.className = 'detail-row';
                    const lang = I18N.lang;
                    const scoreText = id === '5' ? `${Math.round(data.score)} ms RT` : `${Math.round(data.score)} pts`;

                    row.innerHTML = `
                        <span class="detail-label ${lang === 'zh' ? 'zh' : ''}">${MODULES[id].title[lang]}</span>
                        <span class="detail-value">${scoreText} · ${Math.round(data.time)}s</span>
                    `;
                    details.appendChild(row);
                });
                
                let rec = [];
                const avgErrors = Object.values(this.modules).reduce((sum, d) => sum + (d.errors || 0), 0) / this.completed.size;
                const scentValues = this.scents;
                
                if (avgScore > 70) {
                    if (scentValues.floral > 60) rec.push('Jasmine');
                    if (scentValues.citrus > 60) rec.push('Bergamot');
                } else if (avgScore > 40) {
                    if (scentValues.woody > 50) rec.push('Sandalwood');
                    if (scentValues.earthy > 50) rec.push('Vetiver');
                    rec.push('Rosemary');
                } else {
                    rec.push('Lavender');
                    if (scentValues.fresh > 50) rec.push('Peppermint');
                    rec.push('Frankincense');
                }
                
                if (avgErrors > 10) rec.push('Chamomile');
                if (avgErrors < 3 && !rec.includes('Bergamot')) rec.push('Lemon');
                
                Object.entries(scentValues).forEach(([scent, value]) => {
                    if (value > 80) {
                        const map = {
                            floral: 'Rose',
                            woody: 'Cedar',
                            citrus: 'Orange',
                            earthy: 'Patchouli',
                            fresh: 'Eucalyptus',
                            spicy: 'Cinnamon'
                        };
                        if (!rec.includes(map[scent])) rec.push(map[scent]);
                    }
                });
                
                if (rec.length === 0) rec.push('Balanced Blend');
                
                document.getElementById('scent-result').textContent = rec.slice(0, 4).join(' + ');
                
                this.drawWheel();
                this.drawReportVisualization();
                
                // NEW: Add scientific visualizations
                this.drawTOCRisk();
                this.drawTrajectoryChart();
                this.drawBrainRadar();
            },
            
            // NEW: tOC Risk Visualization
            drawTOCRisk() {
                const tocValue = this.tOC;
                const avgScore = Object.values(this.modules).reduce((sum, d) => sum + (d.score || 0), 0) / this.completed.size;
                
                // Pseudo-scientific calculation (just for show)
                const cognitiveDeviation = (100 - avgScore) / 100;
                const riskScore = (cognitiveDeviation * 0.6 + (tocValue / 120) * 0.4) * 100;
                
                const riskLevel = riskScore < 25 ? 'stable' : riskScore < 50 ? 'mild' : riskScore < 75 ? 'moderate' : 'high';
                const lang = I18N.lang;
                const riskText = {
                    'stable': lang === 'en' ? 'Stable' : '稳定',
                    'mild': lang === 'en' ? 'Low Risk' : '轻度风险',
                    'moderate': lang === 'en' ? 'Moderate Risk' : '中度风险',
                    'high': lang === 'en' ? 'High Risk' : '高风险'
                };
                
                document.getElementById('toc-risk-display').innerHTML = lang === 'en' ? `
                    <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">
                        <strong>Risk Level:</strong> <span class="status ${riskLevel === 'stable' ? 'good' : 'warning'}">${riskText[riskLevel]}</span>
                    </p>
                    <p style="font-size: 0.75rem; color: rgba(42, 42, 42, 0.7);">
                        Calculation: Cognitive Bias ${cognitiveDeviation.toFixed(2)} + tOC Normalized ${(tocValue/120).toFixed(2)} = ${riskScore.toFixed(1)}/100
                    </p>
                ` : `
                    <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">
                        <strong>风险等级：</strong><span class="status ${riskLevel === 'stable' ? 'good' : 'warning'}">${riskText[riskLevel]}</span>
                    </p>
                    <p style="font-size: 0.75rem; color: rgba(42, 42, 42, 0.7);">
                        计算依据：认知偏差 ${cognitiveDeviation.toFixed(2)} + tOC标准化值 ${(tocValue/120).toFixed(2)} = ${riskScore.toFixed(1)}/100
                    </p>
                `;
                
                document.getElementById('current-toc-display').textContent = tocValue;
                
                // Position risk indicator
                const indicator = document.getElementById('risk-indicator');
                const position = Math.min(95, riskScore);
                indicator.style.left = position + '%';
            },
            
            // NEW: 12-Month Trajectory Chart (D3.js)
            drawTrajectoryChart() {
                const container = document.getElementById('trajectory-chart');
                container.innerHTML = '';
                
                // Simulate 12-month data (based on current tOC)
                const months = 12;
                const baselineTOC = this.tOC;
                const avgScore = Object.values(this.modules).reduce((sum, d) => sum + (d.score || 0), 0) / this.completed.size;
                const growthRate = avgScore > 70 ? 0.1 : avgScore > 50 ? 0.15 : 0.25; // Lower scores = faster tOC growth
                
                const data = [];
                for (let i = 0; i <= months; i++) {
                    const noise = (Math.random() - 0.5) * 2; // Add some randomness
                    const toc = baselineTOC + (i * growthRate) + noise;
                    data.push({ month: i, tOC: Math.max(baselineTOC, toc) });
                }
                
                // D3 visualization
                const margin = { top: 20, right: 30, bottom: 40, left: 50 };
                const width = container.parentElement.clientWidth - margin.left - margin.right;
                const height = 220 - margin.top - margin.bottom;
                
                const svg = d3.select(container)
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom)
                    .append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Scales
                const x = d3.scaleLinear()
                    .domain([0, months])
                    .range([0, width]);
                
                const y = d3.scaleLinear()
                    .domain([Math.min(...data.map(d => d.tOC)) - 2, Math.max(...data.map(d => d.tOC)) + 2])
                    .range([height, 0]);
                
                // Axes
                svg.append('g')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(12).tickFormat(d => d + 'm'))
                    .selectAll('text')
                    .style('font-size', '10px')
                    .style('fill', '#2a2a2a');
                
                svg.append('g')
                    .call(d3.axisLeft(y))
                    .selectAll('text')
                    .style('font-size', '10px')
                    .style('fill', '#2a2a2a');
                
                // Y-axis label
                svg.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -35)
                    .attr('x', -height / 2)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '11px')
                    .style('fill', '#2a2a2a')
                    .text('tOC Value');
                
                // Line
                const line = d3.line()
                    .x(d => x(d.month))
                    .y(d => y(d.tOC))
                    .curve(d3.curveMonotoneX);
                
                svg.append('path')
                    .datum(data)
                    .attr('fill', 'none')
                    .attr('stroke', '#c02625')
                    .attr('stroke-width', 2.5)
                    .attr('d', line);
                
                // Data points
                svg.selectAll('circle')
                    .data(data)
                    .enter().append('circle')
                    .attr('cx', d => x(d.month))
                    .attr('cy', d => y(d.tOC))
                    .attr('r', 3)
                    .attr('fill', '#c02625')
                    .on('mouseover', function(event, d) {
                        d3.select(this).attr('r', 5);
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('r', 3);
                    });
            },
            
            // NEW: Brain Fingerprint Radar Chart
            drawBrainRadar() {
                const canvas = document.getElementById('brain-radar');
                const ctx = canvas.getContext('2d');
                
                // Set smaller canvas size for more elegant appearance
                const size = Math.min(380, window.innerWidth - 60);
                canvas.width = size;
                canvas.height = size;
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                
                // Simulated cognitive domains (based on module scores)
                const modules = this.modules;
                
                // Get labels based on current language
                const labelsZh = ['记忆', '注意力', '执行', '语言', '视空间', '速度', '工作记忆', '情绪'];
                const labelsEn = ['Memory', 'Attention', 'Executive', 'Language', 'Spatial', 'Speed', 'Working Mem', 'Emotional'];
                const labels = I18N.lang === 'zh' ? labelsZh : labelsEn;
                
                const cognitiveData = {
                    '0': modules['0'] ? (100 - modules['0'].errors * 5) : 75,
                    '1': modules['1'] ? modules['1'].score : 70,
                    '2': modules['2'] ? modules['2'].score : 65,
                    '3': modules['3'] ? (modules['3'].progress || 70) : 70,
                    '4': modules['4'] ? modules['4'].score : 72,
                    '5': modules['5'] ? Math.max(0, 100 - (modules['5'].score - 200) / 3) : 68,
                    '6': modules['6'] ? modules['6'].score : 75,
                    '7': 70 + (Math.random() * 20 - 10) // Random for demo
                };
                
                // Classify pattern based on data
                const scores = Object.values(cognitiveData);
                const variance = this.calculateVariance(scores);
                const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                
                let patternNameZh, patternNameEn, patternPct;
                if (variance < 50 && avgScore > 70) {
                    patternNameZh = '平衡型';
                    patternNameEn = 'Balanced Profile';
                    patternPct = '45%';
                } else if (scores[0] < 60 && avgScore > 65) {
                    patternNameZh = '海马保留型';
                    patternNameEn = 'Hippocampal-Sparing';
                    patternPct = '30%';
                } else if (scores[2] < 60) {
                    patternNameZh = '执行功能受损型';
                    patternNameEn = 'Executive Deficit';
                    patternPct = '25%';
                } else {
                    patternNameZh = '混合型';
                    patternNameEn = 'Mixed Profile';
                    patternPct = '20%';
                }
                
                const patternName = I18N.lang === 'zh' ? patternNameZh : patternNameEn;
                document.getElementById('pattern-name').textContent = patternName;
                document.getElementById('pattern-percentage').textContent = patternPct;
                
                // Radar chart with refined aesthetics
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 60;
                const values = Object.values(cognitiveData);
                const numPoints = labels.length;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw subtle gradient background circles
                for (let i = 1; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, (radius / 3) * i, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(192, 38, 37, ${0.08 - i * 0.02})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
                
                // Draw axes with subtle styling
                ctx.strokeStyle = 'rgba(42, 42, 42, 0.12)';
                ctx.lineWidth = 0.8;
                for (let i = 0; i < numPoints; i++) {
                    const angle = (Math.PI * 2 / numPoints) * i - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * radius,
                        centerY + Math.sin(angle) * radius
                    );
                    ctx.stroke();
                }
                
                // Draw data with gradient fill
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(192, 38, 37, 0.25)');
                gradient.addColorStop(1, 'rgba(192, 38, 37, 0.08)');
                
                ctx.fillStyle = gradient;
                ctx.strokeStyle = 'rgba(192, 38, 37, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < numPoints; i++) {
                    const angle = (Math.PI * 2 / numPoints) * i - Math.PI / 2;
                    const value = values[i] / 100;
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw refined data points
                ctx.fillStyle = '#c02625';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                for (let i = 0; i < numPoints; i++) {
                    const angle = (Math.PI * 2 / numPoints) * i - Math.PI / 2;
                    const value = values[i] / 100;
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                // Draw labels with improved typography
                ctx.save();
                ctx.fillStyle = 'rgba(42, 42, 42, 0.85)';
                ctx.font = '500 12px -apple-system, BlinkMacSystemFont, "Inter", "Noto Sans SC", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = (Math.PI * 2 / numPoints) * i - Math.PI / 2;
                    const labelDist = radius + 35;
                    const x = centerX + Math.cos(angle) * labelDist;
                    const y = centerY + Math.sin(angle) * labelDist;
                    
                    // Subtle text shadow for legibility
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                    ctx.shadowBlur = 2;
                    ctx.fillText(labels[i], x, y);
                }
                ctx.restore();
            },
            
            // Helper function
            calculateVariance(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
            },
        };
        
        // ==================== VISUAL SYSTEM ====================
        const Visual = {
            scene: null,
            camera: null,
            renderer: null,
            current: null,
            animating: false,
            lastTime: 0,
            
            init() {
                try {
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 5;
                    
                    const canvas = document.getElementById('canvas3d');
                    if (!canvas) throw new Error('Canvas not found');
                    
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: window.devicePixelRatio < 2,
                        alpha: true,
                        powerPreference: 'high-performance',
                        stencil: false,
                        depth: true
                    });
                    
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    
                    const throttledResize = PerformanceUtils.throttle(() => this.resize(), 250);
                    window.addEventListener('resize', throttledResize);
                    
                    this.setScene('WELCOME');
                    this.lastTime = performance.now();
                    this.animate();
                    
                    return true;
                } catch(e) {
                    console.error('Visual init error:', e);
                    return false;
                }
            },
            
            resize() {
                if (!this.camera || !this.renderer) return;
                
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (App.state === 'RESULTS') App.drawReportVisualization(); 
            },
            
            setScene(state) {
                try {
                    console.log(`🎬 Setting scene for state: ${state}`);
                    
                    // Thoroughly clean up existing scene
                    if (this.scene) {
                        // Recursively dispose all objects
                        const disposeObject = (obj) => {
                            if (!obj) return;
                            
                            // Remove from parent
                            if (obj.parent) {
                                obj.parent.remove(obj);
                            }
                            
                            // Dispose geometry
                            if (obj.geometry) {
                                obj.geometry.dispose();
                            }
                            
                            // Dispose material(s)
                            if (obj.material) {
                                if (Array.isArray(obj.material)) {
                                    obj.material.forEach(m => {
                                        if (m.map) m.map.dispose();
                                        if (m.lightMap) m.lightMap.dispose();
                                        if (m.bumpMap) m.bumpMap.dispose();
                                        if (m.normalMap) m.normalMap.dispose();
                                        if (m.specularMap) m.specularMap.dispose();
                                        if (m.envMap) m.envMap.dispose();
                                        m.dispose();
                                    });
                                } else {
                                    if (obj.material.map) obj.material.map.dispose();
                                    if (obj.material.lightMap) obj.material.lightMap.dispose();
                                    if (obj.material.bumpMap) obj.material.bumpMap.dispose();
                                    if (obj.material.normalMap) obj.material.normalMap.dispose();
                                    if (obj.material.specularMap) obj.material.specularMap.dispose();
                                    if (obj.material.envMap) obj.material.envMap.dispose();
                                    obj.material.dispose();
                                }
                            }
                            
                            // Recursively dispose children
                            if (obj.children) {
                                while (obj.children.length > 0) {
                                    disposeObject(obj.children[0]);
                                }
                            }
                        };
                        
                        // Clear all scene children
                        while (this.scene.children.length > 0) {
                            disposeObject(this.scene.children[0]);
                        }
                    }
                    
                    this.current = null;
                    
                    // Create new ambient particles for non-game states
                    if (state === 'WELCOME' || state === 'INFO' || state === 'SCENT' || state === 'MODULES' || state === 'RESULTS') {
                        const geom = new THREE.BufferGeometry();
                        const particleCount = 500;
                        const pos = new Float32Array(particleCount * 3);
                        
                        for (let i = 0; i < particleCount; i++) {
                            pos[i*3] = (Math.random() - 0.5) * 20;
                            pos[i*3+1] = (Math.random() - 0.5) * 20;
                            pos[i*3+2] = (Math.random() - 0.5) * 20;
                        }
                        
                        geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                        
                        const mat = new THREE.PointsMaterial({ 
                            size: 0.035, 
                            color: 0xc02625, 
                            transparent: true, 
                            opacity: 0.4
                        });
                        
                        this.current = new THREE.Points(geom, mat);
                        this.scene.add(this.current);
                    }
                    
                    console.log(`✅ Scene set for ${state}`);
                } catch(e) {
                    console.error('❌ setScene error:', e);
                    // Try to at least clear the scene
                    try {
                        if (this.scene) {
                            while (this.scene.children.length > 0) {
                                this.scene.remove(this.scene.children[0]);
                            }
                        }
                    } catch(clearErr) {
                        console.error('Scene clear failed:', clearErr);
                    }
                }
            },
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const now = performance.now();
                const deltaTime = Math.min((now - this.lastTime) / 1000, 0.1); // Cap deltaTime to prevent huge jumps
                this.lastTime = now;
                
                try {
                    // Rotate background particles
                    if (this.current && this.current.rotation) {
                        this.current.rotation.y += 0.05 * deltaTime;
                        this.current.rotation.x += 0.02 * deltaTime;
                    }

                    // Update game module if active
                    if (App.state === 'GAME' && GameEngine.module && !GameEngine.isLoading) {
                        try {
                            GameEngine.update(GameEngine.stats, deltaTime);
                        } catch(gameErr) {
                            console.error('❌ Game update error:', gameErr);
                            // 不再自动退出 - 让用户决定何时退出
                            // 只停止当前模块的更新
                            if (GameEngine.module) {
                                GameEngine.module.isActive = false;
                            }
                        }
                    } else if (App.state === 'SCENT') {
                        try {
                            LumenScent.update(deltaTime);
                        } catch(scentErr) {
                            console.error('Scent update error:', scentErr);
                        }
                    }
                    
                    // Render scene
                    if (this.renderer && this.scene && this.camera) {
                        this.renderer.render(this.scene, this.camera);
                    }
                } catch(e) {
                    console.error('❌ Critical render error:', e);
                    // Try to recover renderer
                    setTimeout(() => {
                        try {
                            if (!this.renderer || !this.scene || !this.camera) {
                                console.log('🔄 Attempting to reinitialize Visual system...');
                                this.init();
                            }
                        } catch(reinitErr) {
                            console.error('Reinit failed:', reinitErr);
                        }
                    }, 100);
                }
            }
        };

        // ==================== GAME ENGINE (WITH DELAYED LOADING) ====================
        const GameEngine = {
            module: null,
            t0: 0,
            stats: { time: 0, score: 0, progress: 0, errors: 0 },
            isLoading: false,
            currentModuleId: null,
            
            start(id) {
                // Prevent loading the same module twice
                if (this.currentModuleId === id && this.module) {
                    console.warn(`⚠️ Module ${id} is already loaded`);
                    return;
                }
                
                if (this.isLoading) {
                    console.warn('⚠️ Module still loading, please wait...');
                    return;
                }
                
                // Clean up any existing module first
                if (this.module) {
                    console.log('🧹 Cleaning up previous module before loading new one...');
                    try {
                        ResourceManager.unregister('gamemodule');
                        this.module = null;
                    } catch(cleanErr) {
                        console.error('Previous module cleanup error:', cleanErr);
                    }
                }
                
                this.isLoading = true;
                this.currentModuleId = id;
                console.log(`🔄 Loading Module ${id}...`);
                
                // Hide all canvas elements
                document.getElementById('crystal-container').style.display = 'none';
                document.getElementById('reflex-canvas').style.display = 'none';
                document.getElementById('mod4-canvas').style.display = 'none';

                // Safety timeout - if module doesn't load in 5 seconds, warn user
                const safetyTimeout = setTimeout(() => {
                    if (this.isLoading) {
                        console.error('⏱️ Module load timeout - 模块加载超时');
                        this.isLoading = false;
                        ResourceManager.unregister('gamemodule');
                        // 不自动跳转 - 显示错误信息让用户决定
                        alert('Module failed to load. Please use the "SAVE & EXIT" button to return.');
                        // App.setState('MODULES');  // 移除自动跳转
                    }
                }, 5000);

                // Delay to ensure DOM is ready
                setTimeout(() => {
                    try {
                        // Create module instance
                        this.module = MODULES[id].create();
                        this.module.id = id;
                        this.t0 = Date.now();
                        this.stats = { time: 0, score: 0, progress: 0, errors: 0 }; 
                        
                        const lang = I18N.lang;
                        document.getElementById('game-title').textContent = MODULES[id].title[lang];
                        
                        // Show intro text
                        const introTextEl = document.getElementById('game-intro-text');
                        introTextEl.textContent = I18N.t(`mod${id}_intro`);
                        introTextEl.classList.add('active-intro');

                        setTimeout(() => {
                            introTextEl.classList.remove('active-intro');
                        }, 3000);
                        
                        // Delayed initialization with error handling
                        setTimeout(() => {
                            try {
                                if (this.module && this.module.init) {
                                    this.module.init();
                                    this.isLoading = false;
                                    clearTimeout(safetyTimeout);
                                    console.log(`✅ Module ${id} loaded successfully`);
                                }
                            } catch(initErr) {
                                console.error(`❌ Module ${id} init error:`, initErr);
                                this.isLoading = false;
                                clearTimeout(safetyTimeout);
                                ResourceManager.unregister('gamemodule');
                                // 不自动跳转 - 让用户手动退出
                                alert(`Module initialization failed: ${initErr.message}\nPlease use "SAVE & EXIT" button to return.`);
                                // App.setState('MODULES');  // 移除自动跳转
                            }
                        }, 100);
                        
                        // Register module for cleanup
                        ResourceManager.register('gamemodule', this.module);
                    } catch (error) {
                        console.error(`❌ Error loading Module ${id}:`, error);
                        this.isLoading = false;
                        clearTimeout(safetyTimeout);
                        // 不自动跳转 - 让用户手动退出
                        alert(`Failed to load module: ${error.message}\nPlease use "SAVE & EXIT" button to return.`);
                        // App.setState('MODULES');  // 移除自动跳转
                    }
                }, 100);
            },

            showTutorial(id) {
                const tutorial = document.getElementById('tutorial-overlay');
                const lang = I18N.lang;
                
                document.getElementById('tutorial-title').textContent = I18N.t(`mod${id}_tut_title`);
                document.getElementById('tutorial-text').textContent = I18N.t(`mod${id}_tut_desc`);

                tutorial.classList.add('active');

                document.getElementById('game-ui').classList.add('active');
                document.getElementById('game-stats').classList.add('active');
                document.getElementById('back-btn').classList.add('active');

                const startButton = document.getElementById('tutorial-start-btn');
                
                const newStartButton = startButton.cloneNode(true);
                startButton.parentNode.replaceChild(newStartButton, startButton);
                
                newStartButton.addEventListener('click', () => {
                    tutorial.classList.remove('active');
                    this.start(id);
                    Sound.play('click');
                });
            },
            
            update(stats, deltaTime) {
                if (!this.module || App.state !== 'GAME' || this.isLoading) return;
                
                try {
                    stats.time = (Date.now() - this.t0) / 1000;
                    this.module.update(stats, deltaTime);
                    
                    document.getElementById('stat-time').textContent = Math.round(stats.time) + 's';
                    
                    if (this.module.id === '5' && typeof stats.score === 'number' && stats.score > 0) {
                        document.getElementById('stat-score').textContent = `${Math.round(stats.score)}ms`;
                    } else if (this.module.id === '5') {
                        document.getElementById('stat-score').textContent = '0ms';
                    } else {
                        document.getElementById('stat-score').textContent = Math.round(stats.score);
                    }
                } catch (error) {
                    console.error('❌ Error in game update:', error);
                }
            },
            
            complete() {
                if (!this.module) return;
                
                const finalScore = this.stats.score;
                const data = { 
                    time: this.stats.time, 
                    score: finalScore || 0, 
                    errors: this.stats.errors 
                };
                
                ResourceManager.unregister('gamemodule');
                this.module = null;
                this.currentModuleId = null;
                this.isLoading = false;
                
                App.completeModule(App.current, data);
            }
        };
        
        // ==================== MODULES ====================
        const MODULES = {
            '1': { 
                title: { en: 'Trace', zh: '轨迹' }, 
                subtitle: { en: 'Sequential Memory', zh: '序列记忆' }, 
                desc: { en: I18N.data.en.mod1_desc, zh: I18N.data.zh.mod1_desc },
                fullDesc: {
                    en: 'Fish schools swim past in fleeting moments. Your task is to count them—a seemingly simple act that reveals the fragility of working memory. As sequences dissolve, you must hold multiple traces simultaneously, reconstructing what has already vanished.',
                    zh: '鱼群在瞬间游过。你的任务是计数——这个看似简单的行为揭示了工作记忆的脆弱性。当序列消散时，你必须同时保持多个痕迹，重建已经消失的事物。'
                },
                science: {
                    en: '<strong>Neural Basis:</strong> Working memory relies on the dorsolateral prefrontal cortex (DLPFC) maintaining active neural representations. N-back tasks show reduced hippocampal activation in early cognitive decline, making sequential tracking a sensitive cognitive marker.',
                    zh: '<strong>神经基础：</strong> 工作记忆依赖于背外侧前额叶皮质(DLPFC)维持活跃的神经表征。N-back任务显示早期认知衰退中海马体激活减少，使序列追踪成为敏感的认知标记。'
                },
                create: () => new Module1() 
            },
            '2': { 
                title: { en: 'Signal', zh: '信号' }, 
                subtitle: { en: 'Sustained Focus', zh: '持续专注' }, 
                desc: { en: I18N.data.en.mod2_desc, zh: I18N.data.zh.mod2_desc },
                fullDesc: {
                    en: 'A lone signal drifts through a field of noise. You must capture it, hold it steady despite the chaos. This is sustained attention in its purest form—the ability to maintain focus when everything conspires to pull you away.',
                    zh: '一个孤独的信号在噪声场中漂移。你必须捕获它，在混乱中保持稳定。这是最纯粹形式的持续注意力——在一切都试图将你拉走时保持专注的能力。'
                },
                science: {
                    en: '<strong>Neural Basis:</strong> The right inferior frontal cortex and anterior cingulate cortex maintain sustained attention. Continuous Performance Tests (CPT) reveal attentional lapses correlate with frontoparietal network disruption in neurodegenerative conditions.',
                    zh: '<strong>神经基础：</strong> 右侧额下回皮质和前扣带回皮质维持持续注意力。持续表现测试(CPT)揭示注意力缺失与神经退行性疾病中额顶叶网络中断相关。'
                },
                create: () => new Module2() 
            },
            '3': { 
                title: { en: 'Schema', zh: '图式' }, 
                subtitle: { en: 'Pattern Recognition', zh: '模式识别' }, 
                desc: { en: I18N.data.en.mod3_desc, zh: I18N.data.zh.mod3_desc },
                fullDesc: {
                    en: 'Patterns emerge from instability. A visual core forms, asking you to recognize it while holding it stable. This dual task—perception and maintenance—mimics how we extract meaning from an ever-shifting world.',
                    zh: '模式从不稳定中涌现。一个视觉核心形成，要求你在保持其稳定的同时识别它。这个双重任务——感知和维持——模拟了我们如何从不断变化的世界中提取意义。'
                },
                science: {
                    en: '<strong>Neural Basis:</strong> Pattern recognition engages the ventral visual stream and prefrontal cortex for schema formation. Studies show impaired pattern completion in medial temporal lobe dysfunction, with the perirhinal cortex critical for object familiarity.',
                    zh: '<strong>神经基础：</strong> 模式识别涉及腹侧视觉流和前额叶皮质进行图式形成。研究显示内侧颞叶功能障碍中模式完成受损，嗅周皮质对物体熟悉度至关重要。'
                },
                create: () => new Module3() 
            },
            '4': { 
                title: { en: 'Phase', zh: '相位' }, 
                subtitle: { en: 'Neural Synchrony', zh: '神经同步' }, 
                desc: { en: I18N.data.en.mod4_desc, zh: I18N.data.zh.mod4_desc },
                fullDesc: {
                    en: 'Waves oscillate in elegant patterns. Your task is to synchronize—matching frequency and amplitude until your wave aligns with the target. This is neural coordination distilled: the brain\'s ability to entrain disparate rhythms.',
                    zh: '波浪以优雅的模式振荡。你的任务是同步——匹配频率和振幅，直到你的波与目标对齐。这是神经协调的精髓：大脑协调不同节律的能力。'
                },
                science: {
                    en: '<strong>Neural Basis:</strong> Neural oscillations (theta, alpha, gamma) coordinate information processing. Disrupted oscillatory coupling in the default mode network predicts cognitive decline. Synchronization training may enhance cross-frequency coupling.',
                    zh: '<strong>神经基础：</strong> 神经振荡(θ、α、γ)协调信息处理。默认模式网络中振荡耦合中断预示认知衰退。同步训练可能增强跨频率耦合。'
                },
                create: () => new Module4() 
            },
            '5': { 
                title: { en: 'Arc', zh: '弧' }, 
                subtitle: { en: 'Motor Inhibition', zh: '运动抑制' }, 
                desc: { en: I18N.data.en.mod5_desc, zh: I18N.data.zh.mod5_desc },
                fullDesc: {
                    en: 'Targets appear. Some demand action, others demand restraint. This is the sensorimotor arc—the millisecond decision between go and no-go. Executive control at its most fundamental: the ability to inhibit prepotent responses.',
                    zh: '目标出现。有些需要行动，有些需要克制。这是感知运动弧——在执行和不执行之间的毫秒决定。最基本的执行控制：抑制优势反应的能力。'
                },
                science: {
                    en: '<strong>Neural Basis:</strong> The pre-supplementary motor area (pre-SMA) and right inferior frontal gyrus (rIFG) mediate response inhibition. Go/No-Go tasks reveal basal ganglia dysfunction in early neurodegeneration, where impaired inhibitory control emerges.',
                    zh: '<strong>神经基础：</strong> 前辅助运动区(pre-SMA)和右额下回(rIFG)介导反应抑制。Go/No-Go任务揭示早期神经退化中基底神经节功能障碍，抑制控制受损。'
                },
                create: () => new Module5() 
            },
            '6': { 
                title: { en: 'Flow', zh: '流' }, 
                subtitle: { en: 'Interoceptive Sync', zh: '本体同步' }, 
                desc: { en: I18N.data.en.mod6_desc, zh: I18N.data.zh.mod6_desc },
                fullDesc: {
                    en: 'Breath becomes visible as flowing patterns of fluid dynamics. The 4-7-8 rhythm guides you: inhale (4), hold (7), exhale (8). This is interoceptive awareness: the body\'s internal landscape made conscious.',
                    zh: '呼吸变成可见的流动图案——流体动力学的旋涡。4-7-8节奏引导你：吸气(4)，屏息(7)，呼气(8)。这是本体感知：身体的内部景观变得有意识。'
                },
                science: {
                    en: '<strong>Neural Basis:</strong> The insula integrates interoceptive signals with cognitive processing. Breathing exercises activate the vagus nerve and enhance heart rate variability (HRV). Studies link breath-focused practices to increased anterior cingulate cortex activity and improved emotional regulation.',
                    zh: '<strong>神经基础：</strong> 脑岛将本体感知信号与认知处理整合。呼吸练习激活迷走神经并增强心率变异性(HRV)。研究将专注呼吸的练习与前扣带回皮质活动增加和情绪调节改善联系起来。'
                },
                create: () => new Module6() 
            }
        };
        
        // ==================== MODULE 1: FISH SCHOOL COUNTER ====================
        class Module1 {
            init() {
                console.log('🐟 Module 1 initializing...');
                this.isActive = true;
                this.canvas = document.createElement('canvas');
                this.canvas.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 90vw; max-height: 70vh; border: 2px solid rgba(192, 38, 37, 0.3); background: #f5f5f0;';
                
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7, 600);
                this.canvas.width = size;
                this.canvas.height = size;
                this.ctx = this.canvas.getContext('2d');
                
                document.getElementById('game-screen').appendChild(this.canvas);
                
                const difficulty = App.tOC;
                this.round = 0;
                this.maxRounds = 3 + Math.floor(difficulty / 30);
                this.currentPhase = 'showing';
                this.schools = [];
                this.userAnswers = [];
                this.correctAnswers = [];
                
                this.startRound();
            }
            
            startRound() {
                this.round++;
                this.currentPhase = 'showing';
                this.schools = [];
                this.correctAnswers = [];
                
                const numSchools = this.round === 1 ? 1 : 2;
                
                for (let s = 0; s < numSchools; s++) {
                    const numFish = 3 + Math.floor(Math.random() * 5);
                    this.correctAnswers.push(numFish);
                    
                    const school = {
                        fish: [],
                        shown: false,
                        showTime: s * 4000 + 1000
                    };
                    
                    const baseY = this.canvas.height / 2 + (s - 0.5) * 100;
                    const startX = -100;
                    
                    for (let i = 0; i < numFish; i++) {
                        school.fish.push({
                            x: startX - i * 60,
                            y: baseY + (Math.random() - 0.5) * 40,
                            size: 15 + Math.random() * 10,
                            speed: 2 + Math.random() * 1,
                            phase: Math.random() * Math.PI * 2,
                            particles: this.createFishParticles()
                        });
                    }
                    
                    this.schools.push(school);
                }
                
                this.animationStart = Date.now();
            }
            
            createFishParticles() {
                const particles = [];
                const numParticles = 30;
                for (let i = 0; i < numParticles; i++) {
                    particles.push({
                        angle: (i / numParticles) * Math.PI * 2,
                        dist: Math.random() * 8 + 5,
                        size: Math.random() * 2 + 1
                    });
                }
                return particles;
            }
            
            drawFish(fish, time) {
                const ctx = this.ctx;
                const wobble = Math.sin(time * 3 + fish.phase) * 3;
                
                fish.particles.forEach(p => {
                    const x = fish.x + Math.cos(p.angle) * p.dist;
                    const y = fish.y + Math.sin(p.angle) * p.dist + wobble;
                    
                    ctx.fillStyle = `rgba(255, 122, 92, ${0.6 + Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            showAnswerPrompt() {
                this.currentPhase = 'answering';
                const overlay = document.getElementById('question-overlay');
                const questionText = document.getElementById('question-text');
                const optionsDiv = document.getElementById('answer-options');
                
                const lang = I18N.lang;
                if (this.round === 1 || this.correctAnswers.length === 1) {
                    questionText.textContent = lang === 'en' ? 'How many fish did you see?' : '你看到了几条鱼?';
                } else {
                    questionText.textContent = lang === 'en' ? 
                        'First school count? Then second school count?' : 
                        '第一群有几条?第二群有几条?';
                }
                
                optionsDiv.innerHTML = '';
                
                const createInput = (placeholder) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.max = '20';
                    input.placeholder = placeholder;
                    input.style.cssText = 'width: 100%; padding: 1rem; margin-bottom: 0.8rem; border: 1px solid rgba(192, 38, 37, 0.3); font-size: 1rem;';
                    return input;
                };
                
                const input1 = createInput(this.correctAnswers.length === 1 ? 'Enter count' : 'First school');
                optionsDiv.appendChild(input1);
                
                let input2;
                if (this.correctAnswers.length === 2) {
                    input2 = createInput('Second school');
                    optionsDiv.appendChild(input2);
                }
                
                const submitBtn = document.createElement('button');
                submitBtn.className = 'btn accent';
                submitBtn.textContent = lang === 'en' ? 'SUBMIT' : '提交';
                submitBtn.style.cssText = 'width: 100%; margin-top: 1rem;';
                submitBtn.addEventListener('click', () => {
                    const ans1 = parseInt(input1.value);
                    const ans2 = input2 ? parseInt(input2.value) : null;
                    
                    let correct = 0;
                    if (ans1 === this.correctAnswers[0]) correct++;
                    if (this.correctAnswers.length === 2 && ans2 === this.correctAnswers[1]) correct++;
                    
                    if (correct === this.correctAnswers.length) {
                        GameEngine.stats.score += 20;
                        Sound.play('success');
                    } else {
                        GameEngine.stats.errors++;
                        GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 10);
                        Sound.play('click', 'C2', 0.5);
                    }
                    
                    overlay.classList.remove('active');
                    
                    // 自由体验模式：记录轮次但不强制完成
                    // if (this.round >= this.maxRounds) {
                    //     GameEngine.complete();
                    // } else {
                    //     setTimeout(() => this.startRound(), 1000);
                    // }
                    
                    // 改为：总是开始下一轮，让用户自由体验
                    setTimeout(() => this.startRound(), 1000);
                });
                optionsDiv.appendChild(submitBtn);
                
                overlay.classList.add('active');
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                const ctx = this.ctx;
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.currentPhase === 'showing') {
                    const elapsed = Date.now() - this.animationStart;
                    const time = elapsed / 1000;
                    
                    let allDone = true;
                    
                    this.schools.forEach(school => {
                        if (elapsed > school.showTime && !school.shown) {
                            school.shown = true;
                        }
                        
                        if (school.shown) {
                            school.fish.forEach(fish => {
                                fish.x += fish.speed;
                                this.drawFish(fish, time);
                            });
                            
                            if (school.fish[school.fish.length - 1].x < this.canvas.width + 100) {
                                allDone = false;
                            }
                        } else {
                            allDone = false;
                        }
                    });
                    
                    if (allDone && elapsed > Math.max(...this.schools.map(s => s.showTime)) + 5000) {
                        this.showAnswerPrompt();
                    }
                }
            }
            
            cleanup() {
                console.log('🧹 Cleaning up Module 1...');
                this.isActive = false;
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                const overlay = document.getElementById('question-overlay');
                if (overlay) overlay.classList.remove('active');
                console.log('✓ Module 1 cleaned up');
            }
        }

        // ==================== MODULE 2: SIGNAL ====================
        class Module2 {
            init() {
                console.log('📡 Module 2 initializing...');
                this.focusLevel = 0;
                this.focusDuration = 0;
                this.inBreakthrough = false;
                this.timeOffTarget = 0;
                this.lastSoundTime = 0;
                this.breakthroughs = 0;
                this.totalBreakthroughs = 2;

                const difficulty = App.tOC;
                this.signalSpeed = 1.2 + (difficulty / 100) * 1.5;
                this.trackingRadius = 0.20 - (difficulty / 100) * 0.12;
                this.requiredFocusDuration = 5 - (difficulty / 100) * 2;
                this.isActive = true;

                this.pointer = { x: 0, y: 0, isDown: false };
                this.onMove = (e) => {
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    this.pointer.x = (clientX / innerWidth) * 2 - 1;
                    this.pointer.y = -(clientY / innerHeight) * 2 + 1;
                };
                this.onDown = () => { 
                    this.pointer.isDown = true; 
                    if(this.isActive) Sound.start('module2', 'C4', 0.4);
                };
                this.onUp = () => { 
                    this.pointer.isDown = false; 
                    if(this.isActive) Sound.release('module2');
                };

                document.addEventListener('mousemove', this.onMove);
                document.addEventListener('touchmove', this.onMove, { passive: false });
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('touchstart', this.onDown, { passive: false });
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchend', this.onUp);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_time: { value: 0 },
                        u_focus_level: { value: 0.0 },
                        u_signal_speed: { value: this.signalSpeed },
                        u_breakthrough: { value: 0.0 },
                        u_focus_progress: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float u_time;
                        uniform float u_focus_level;
                        uniform float u_signal_speed;
                        uniform float u_breakthrough;
                        uniform float u_focus_progress;
                        varying vec2 vUv;

                        float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
                        float noise (in vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f*f*(3.0-2.0*f); return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }
                        float fbm (in vec2 st) { float value = 0.0; float amplitude = .5; for (int i = 0; i < 4; i++) { value += amplitude * noise(st); st *= 2.; amplitude *= .5; } return value; }

                        void main() {
                            vec2 st = vUv * vec2(0.8, 1.5) + vec2(0.0, -u_time * 0.05);
                            float fbm_val = fbm(st);
                            
                            vec3 color1 = vec3(0.5, 0.1, 0.2);
                            vec3 color2 = vec3(0.8, 0.3, 0.1);
                            vec3 color3 = vec3(0.9, 0.7, 0.5);
                            
                            vec3 nebula_color = mix(color1, color2, smoothstep(0.3, 0.6, fbm_val));
                            nebula_color = mix(nebula_color, color3, smoothstep(0.7, 0.9, fbm_val));

                            float signalY = sin(u_time * u_signal_speed) * 0.4 + 0.5;
                            float distToSignal = abs(vUv.y - signalY);
                            float signalClarity = 1.0 - smoothstep(0.0, 0.05, distToSignal);
                            float signal = sin(vUv.x * 80.0 + u_time * 10.0) * 0.5 + 0.5;
                            signal = smoothstep(0.7, 0.71, signal) * signalClarity;

                            float static_noise = random(vUv * 2.0 - u_time * 0.1);
                            vec3 noise_color = vec3(static_noise * 0.5);

                            vec3 final_color = mix(noise_color, nebula_color, smoothstep(0.1, 0.8, u_focus_level));
                            final_color += vec3(signal) * (0.4 + u_focus_level * 0.6);
                            
                            float breakthrough_wave = 1.0 - smoothstep(0.0, 0.8, abs(distance(vUv, vec2(0.5)) - u_breakthrough * 0.7));
                            vec3 breakthrough_color = nebula_color * 1.8 + breakthrough_wave;
                            final_color = mix(final_color, breakthrough_color, u_breakthrough);

                            gl_FragColor = vec4(final_color, 1.0);
                        }
                    `
                });
                this.screenMesh = new THREE.Mesh(new THREE.PlaneGeometry(16, 9), this.material);
                this.screenMesh.position.z = -1;
                Visual.scene.add(this.screenMesh);
            }

            update(stats, deltaTime) {
                this.material.uniforms.u_time.value = stats.time;

                const signalY = Math.sin(stats.time * this.signalSpeed) * 0.4 + 0.5;
                const pointerYNorm = this.pointer.y * 0.5 + 0.5;
                const dist = Math.abs(pointerYNorm - signalY);
                let isOnTarget = this.pointer.isDown && dist < this.trackingRadius;
                
                if (isOnTarget) {
                    this.focusLevel = Math.min(1.0, this.focusLevel + deltaTime * 0.25); // 慢速恢复
                } else {
                    this.focusLevel = Math.max(0.0, this.focusLevel - deltaTime * 0.5); // 较快降低
                }
                this.material.uniforms.u_focus_level.value = this.focusLevel;

                if (this.focusLevel > 0.95 && !this.inBreakthrough) {
                    this.focusDuration += deltaTime;
                    this.timeOffTarget = 0;
                } else {
                    if (this.focusDuration > 0) {
                        this.timeOffTarget += deltaTime;
                        if (this.timeOffTarget > 0.5) { this.focusDuration = 0; }
                    }
                }
                this.material.uniforms.u_focus_progress.value = this.focusDuration / this.requiredFocusDuration;

                if (this.focusDuration > this.requiredFocusDuration && !this.inBreakthrough) {
                    this.inBreakthrough = true;
                    this.breakthroughs++;
                    Sound.play('breakthrough');
                    setTimeout(() => {
                        this.inBreakthrough = false;
                        this.focusDuration = 0;
                    }, 2000);
                }
                
                // 完成后不暗化，改为明亮的庆祝效果
                if (this.inBreakthrough) {
                    const breakthroughProgress = (this.focusDuration - this.requiredFocusDuration) / 2.0;
                    this.material.uniforms.u_breakthrough.value = Math.sin(Math.min(breakthroughProgress, 1.0) * Math.PI) * 0.6; // 降低强度，保持明亮
                } else {
                    this.material.uniforms.u_breakthrough.value = Math.max(0.0, this.material.uniforms.u_breakthrough.value - deltaTime * 1.5);
                }

                if (isOnTarget && stats.time > this.lastSoundTime + 0.1) {
                    // Safe audio with existence check
                    if (Sound.synths.module2 && Sound.synths.module2.frequency && Sound.synths.module2.frequency.rampTo) {
                        try {
                            Sound.synths.module2.frequency.rampTo(400 + Math.random() * 200, 0.2);
                        } catch(err) {
                            console.warn('Audio error:', err);
                        }
                    }
                    this.lastSoundTime = stats.time;
                } else if (!isOnTarget && this.pointer.isDown) {
                    if (Sound.synths.module2 && Sound.synths.module2.frequency && Sound.synths.module2.frequency.rampTo) {
                        try {
                            Sound.synths.module2.frequency.rampTo(200 + Math.random() * 100, 0.5);
                        } catch(err) {
                            console.warn('Audio error:', err);
                        }
                    }
                }

                // Free experience mode
                stats.score = this.breakthroughs * 10; // Score based on breakthroughs

                // 移除强制完成 - 用户可随时退出
                // if (this.breakthroughs >= this.totalBreakthroughs) {
                //     GameEngine.complete();
                // }
            }

            cleanup() {
                console.log('🧹 Cleaning up Module 2...');
                this.isActive = false;
                Sound.release('module2');      
                
                document.removeEventListener('mousemove', this.onMove);
                document.removeEventListener('touchmove', this.onMove);
                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchend', this.onUp);      
                
                if (Visual.scene && this.screenMesh) {
                    Visual.scene.remove(this.screenMesh);
                    if (this.screenMesh.geometry) this.screenMesh.geometry.dispose();
                    if (this.screenMesh.material) this.screenMesh.material.dispose();
                }      
                this.screenMesh = null;
                this.material = null;
                console.log('✓ Module 2 cleaned up');
            }
        }

        // ==================== MODULE 3: PATTERN (BASED ON WORKING VERSION) ====================
        // ==================== MODULE 3: AESTHETIC BREATHING REVOLUTION ====================
        class Module3 {
            init() {
                console.log('🌸 Module 3 - Refined Breathing System initializing...');
                this.isActive = true;
                this.phase = 'breathing';
                this.score = 0;
                this.questionCount = 0;
                this.maxQuestions = 12 + Math.floor(App.tOC / 20);
                
                // ========== BREATHING & INTERACTION ==========
                this.breathTime = 0;
                this.breathCycleTime = 4.0; // 4秒完整呼吸周期
                this.isHolding = false;
                this.holdTime = 0;
                
                // ========== VISUAL ELEMENTS ==========
                this.group = new THREE.Group();
                
                // 背景
                const bgGeometry = new THREE.PlaneGeometry(20, 20);
                const bgMaterial = new THREE.MeshBasicMaterial({
                    color: 0xf5f5f0,
                    transparent: true,
                    opacity: 0.3
                });
                this.background = new THREE.Mesh(bgGeometry, bgMaterial);
                this.background.position.z = -5;
                this.group.add(this.background);
                
                // 目标环（静态毛玻璃效果 + 流畅呼吸）
                this.targetRing = this.createFrostedGlassRing(1.0, 0xc02625);
                this.group.add(this.targetRing);
                
                // 玩家跟随环（按住时跟随呼吸）
                this.playerRing = this.createSmoothRing(0.5, 0x2a2a2a);
                this.playerRing.scale.set(0, 0, 1);
                this.group.add(this.playerRing);
                
                // 匹配指示器（重叠时发光）
                this.matchRing = this.createSmoothRing(1.0, 0x00cc00);
                this.matchRing.scale.set(0, 0, 1);
                this.matchRing.position.z = 0.02;
                this.group.add(this.matchRing);
                
                // 外圈指示点（随呼吸波峰提示）
                this.indicatorDots = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const dot = this.createDot();
                    dot.userData = { angle, baseRadius: 1.5 };
                    this.indicatorDots.push(dot);
                    this.group.add(dot);
                }
                
                // 神经网络装饰
                this.neurons = [];
                this.createNeuralNetwork();
                
                this.particles = [];
                
                Visual.scene.add(this.group);
                
                // 显示提示
                const breathHint = document.getElementById('breath-hint');
                if (breathHint) {
                    breathHint.classList.add('active');
                }
                
                // ========== EXPANDED QUESTION BANK ==========
                this.questionBank = [
                    // ===== Level 1: 基础题 (30题) =====
                    // 语义归类
                    { cat: 'semantic', level: 1, q_en: "Which doesn't belong: Rose, Tulip, Oak, Daisy?", q_zh: "哪个不属于同类：玫瑰、郁金香、橡树、雏菊？", a_en: ["Rose", "Tulip", "Oak", "Daisy"], a_zh: ["玫瑰", "郁金香", "橡树", "雏菊"], correct: 2 },
                    { cat: 'semantic', level: 1, q_en: "Odd one out: Apple, Orange, Carrot, Banana?", q_zh: "找出不同：苹果、橙子、胡萝卜、香蕉？", a_en: ["Apple", "Orange", "Carrot", "Banana"], a_zh: ["苹果", "橙子", "胡萝卜", "香蕉"], correct: 2 },
                    { cat: 'semantic', level: 1, q_en: "Which is not a mammal: Dolphin, Shark, Whale, Seal?", q_zh: "哪个不是哺乳动物：海豚、鲨鱼、鲸鱼、海豹？", a_en: ["Dolphin", "Shark", "Whale", "Seal"], a_zh: ["海豚", "鲨鱼", "鲸鱼", "海豹"], correct: 1 },
                    { cat: 'semantic', level: 1, q_en: "Which is a bird: Dog, Cat, Eagle, Fish?", q_zh: "哪个是鸟类：狗、猫、鹰、鱼？", a_en: ["Dog", "Cat", "Eagle", "Fish"], a_zh: ["狗", "猫", "鹰", "鱼"], correct: 2 },
                    { cat: 'semantic', level: 1, q_en: "Odd tool: Hammer, Screwdriver, Wrench, Pencil?", q_zh: "找出不同：锤子、螺丝刀、扳手、铅笔？", a_en: ["Hammer", "Screwdriver", "Wrench", "Pencil"], a_zh: ["锤子", "螺丝刀", "扳手", "铅笔"], correct: 3 },
                    { cat: 'semantic', level: 1, q_en: "Which is not a color: Red, Green, Square, Blue?", q_zh: "哪个不是颜色：红色、绿色、方形、蓝色？", a_en: ["Red", "Green", "Square", "Blue"], a_zh: ["红色", "绿色", "方形", "蓝色"], correct: 2 },
                    { cat: 'semantic', level: 1, q_en: "Odd one: Lion, Tiger, Elephant, Leopard?", q_zh: "找出不同：狮子、老虎、大象、豹子？", a_en: ["Lion", "Tiger", "Elephant", "Leopard"], a_zh: ["狮子", "老虎", "大象", "豹子"], correct: 2 },
                    { cat: 'semantic', level: 1, q_en: "Which is not a body part: Head, Hand, Table, Foot?", q_zh: "哪个不是身体部位：头、手、桌子、脚？", a_en: ["Head", "Hand", "Table", "Foot"], a_zh: ["头", "手", "桌子", "脚"], correct: 2 },
                    
                    // 词语联想
                    { cat: 'association', level: 1, q_en: "Ocean makes you think of:", q_zh: "海洋让你想到：", a_en: ["Whale", "Tiger", "Cloud", "Book"], a_zh: ["鲸鱼", "老虎", "云", "书"], correct: 0 },
                    { cat: 'association', level: 1, q_en: "Winter is associated with:", q_zh: "冬天联想到：", a_en: ["Snow", "Sun", "Flower", "Swimming"], a_zh: ["雪", "太阳", "花", "游泳"], correct: 0 },
                    { cat: 'association', level: 1, q_en: "Hospital reminds you of:", q_zh: "医院让你想起：", a_en: ["Doctor", "Chef", "Artist", "Driver"], a_zh: ["医生", "厨师", "艺术家", "司机"], correct: 0 },
                    { cat: 'association', level: 1, q_en: "Night is connected to:", q_zh: "夜晚关联到：", a_en: ["Moon", "Sun", "Morning", "Noon"], a_zh: ["月亮", "太阳", "早晨", "中午"], correct: 0 },
                    { cat: 'association', level: 1, q_en: "School reminds you of:", q_zh: "学校让你想起：", a_en: ["Student", "Pilot", "Farmer", "Sailor"], a_zh: ["学生", "飞行员", "农民", "水手"], correct: 0 },
                    { cat: 'association', level: 1, q_en: "Kitchen is connected to:", q_zh: "厨房关联到：", a_en: ["Cooking", "Sleeping", "Swimming", "Flying"], a_zh: ["烹饪", "睡觉", "游泳", "飞行"], correct: 0 },
                    
                    // 逻辑判断
                    { cat: 'logic', level: 1, q_en: "Birds can fly?", q_zh: "鸟会飞吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 1, q_en: "Fish live in trees?", q_zh: "鱼住在树上吗？", a_en: ["No", "Yes"], a_zh: ["否", "是"], correct: 0 },
                    { cat: 'logic', level: 1, q_en: "Sun is bright?", q_zh: "太阳是明亮的吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 1, q_en: "Cats can swim?", q_zh: "猫会游泳吗？", a_en: ["No", "Yes"], a_zh: ["否", "是"], correct: 0 },
                    
                    // 数学
                    { cat: 'math', level: 1, q_en: "2 + 2 = ?", q_zh: "2 + 2 = ?", a_en: ["4", "3", "5", "6"], a_zh: ["4", "3", "5", "6"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "5 - 3 = ?", q_zh: "5 - 3 = ?", a_en: ["2", "1", "3", "4"], a_zh: ["2", "1", "3", "4"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "4 + 3 = ?", q_zh: "4 + 3 = ?", a_en: ["7", "6", "8", "9"], a_zh: ["7", "6", "8", "9"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "9 - 5 = ?", q_zh: "9 - 5 = ?", a_en: ["4", "3", "5", "6"], a_zh: ["4", "3", "5", "6"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "6 + 2 = ?", q_zh: "6 + 2 = ?", a_en: ["8", "7", "9", "10"], a_zh: ["8", "7", "9", "10"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "7 - 4 = ?", q_zh: "7 - 4 = ?", a_en: ["3", "2", "4", "5"], a_zh: ["3", "2", "4", "5"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "3 + 5 = ?", q_zh: "3 + 5 = ?", a_en: ["8", "7", "9", "10"], a_zh: ["8", "7", "9", "10"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "8 - 2 = ?", q_zh: "8 - 2 = ?", a_en: ["6", "5", "7", "8"], a_zh: ["6", "5", "7", "8"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "1 + 7 = ?", q_zh: "1 + 7 = ?", a_en: ["8", "7", "9", "6"], a_zh: ["8", "7", "9", "6"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "10 - 6 = ?", q_zh: "10 - 6 = ?", a_en: ["4", "3", "5", "6"], a_zh: ["4", "3", "5", "6"], correct: 0 },
                    { cat: 'math', level: 1, q_en: "5 + 4 = ?", q_zh: "5 + 4 = ?", a_en: ["9", "8", "10", "7"], a_zh: ["9", "8", "10", "7"], correct: 0 },
                    
                    // ===== Level 2: 进阶题 (30题) =====
                    { cat: 'semantic', level: 2, q_en: "Which is not furniture: Chair, Table, Piano, Lamp?", q_zh: "哪个不是家具：椅子、桌子、钢琴、台灯？", a_en: ["Chair", "Table", "Piano", "Lamp"], a_zh: ["椅子", "桌子", "钢琴", "台灯"], correct: 2 },
                    { cat: 'semantic', level: 2, q_en: "Odd vehicle: Car, Bus, Bicycle, Airplane?", q_zh: "找出不同：汽车、公交车、自行车、飞机？", a_en: ["Car", "Bus", "Bicycle", "Airplane"], a_zh: ["汽车", "公交车", "自行车", "飞机"], correct: 3 },
                    { cat: 'semantic', level: 2, q_en: "Which is not a beverage: Water, Milk, Soup, Juice?", q_zh: "哪个不是饮料：水、牛奶、汤、果汁？", a_en: ["Water", "Milk", "Soup", "Juice"], a_zh: ["水", "牛奶", "汤", "果汁"], correct: 2 },
                    { cat: 'semantic', level: 2, q_en: "Odd season: Spring, Summer, December, Winter?", q_zh: "找出不同：春天、夏天、十二月、冬天？", a_en: ["Spring", "Summer", "December", "Winter"], a_zh: ["春天", "夏天", "十二月", "冬天"], correct: 2 },
                    { cat: 'semantic', level: 2, q_en: "Which is not clothing: Shirt, Pants, Watch, Shoes?", q_zh: "哪个不是衣物：衬衫、裤子、手表、鞋子？", a_en: ["Shirt", "Pants", "Watch", "Shoes"], a_zh: ["衬衫", "裤子", "手表", "鞋子"], correct: 2 },
                    { cat: 'semantic', level: 2, q_en: "Odd profession: Doctor, Teacher, Student, Engineer?", q_zh: "找出不同：医生、教师、学生、工程师？", a_en: ["Doctor", "Teacher", "Student", "Engineer"], a_zh: ["医生", "教师", "学生", "工程师"], correct: 2 },
                    { cat: 'semantic', level: 2, q_en: "Which is not a musical instrument: Piano, Violin, Radio, Guitar?", q_zh: "哪个不是乐器：钢琴、小提琴、收音机、吉他？", a_en: ["Piano", "Violin", "Radio", "Guitar"], a_zh: ["钢琴", "小提琴", "收音机", "吉他"], correct: 2 },
                    { cat: 'semantic', level: 2, q_en: "Which is not electronic: Phone, Computer, Candle, Television?", q_zh: "哪个不是电器：电话、电脑、蜡烛、电视？", a_en: ["Phone", "Computer", "Candle", "Television"], a_zh: ["电话", "电脑", "蜡烛", "电视"], correct: 2 },
                    
                    { cat: 'association', level: 2, q_en: "Library makes you think of:", q_zh: "图书馆让你想到：", a_en: ["Books", "Food", "Cars", "Music"], a_zh: ["书籍", "食物", "汽车", "音乐"], correct: 0 },
                    { cat: 'association', level: 2, q_en: "Rain is related to:", q_zh: "雨关联到：", a_en: ["Umbrella", "Fire", "Desert", "Ice cream"], a_zh: ["雨伞", "火", "沙漠", "冰淇淋"], correct: 0 },
                    { cat: 'association', level: 2, q_en: "Birthday reminds you of:", q_zh: "生日让你想起：", a_en: ["Cake", "Homework", "Medicine", "Traffic"], a_zh: ["蛋糕", "作业", "药物", "交通"], correct: 0 },
                    { cat: 'association', level: 2, q_en: "Music is connected to:", q_zh: "音乐关联到：", a_en: ["Instrument", "Hammer", "Vegetable", "Clock"], a_zh: ["乐器", "锤子", "蔬菜", "时钟"], correct: 0 },
                    { cat: 'association', level: 2, q_en: "Airport makes you think of:", q_zh: "机场让你想到：", a_en: ["Airplane", "Ship", "Bicycle", "Train"], a_zh: ["飞机", "轮船", "自行车", "火车"], correct: 0 },
                    { cat: 'association', level: 2, q_en: "Desert reminds you of:", q_zh: "沙漠让你想起：", a_en: ["Sand", "Ocean", "Forest", "Snow"], a_zh: ["沙子", "海洋", "森林", "雪"], correct: 0 },
                    
                    { cat: 'antonym', level: 2, q_en: "Opposite of 'Happy':", q_zh: "'快乐'的反义词：", a_en: ["Sad", "Excited", "Calm", "Tired"], a_zh: ["悲伤", "兴奋", "平静", "疲倦"], correct: 0 },
                    { cat: 'antonym', level: 2, q_en: "Opposite of 'Hot':", q_zh: "'热'的反义词：", a_en: ["Cold", "Warm", "Cool", "Mild"], a_zh: ["冷", "温暖", "凉", "温和"], correct: 0 },
                    { cat: 'synonym', level: 2, q_en: "Similar to 'Big':", q_zh: "'大'的近义词：", a_en: ["Large", "Small", "Tiny", "Little"], a_zh: ["巨大", "小", "微小", "小的"], correct: 0 },
                    { cat: 'antonym', level: 2, q_en: "Opposite of 'Up':", q_zh: "'上'的反义词：", a_en: ["Down", "Side", "Forward", "Back"], a_zh: ["下", "侧", "前", "后"], correct: 0 },
                    
                    { cat: 'logic', level: 2, q_en: "Sun rises in the east?", q_zh: "太阳从东方升起吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 2, q_en: "Ice is hot?", q_zh: "冰是热的吗？", a_en: ["No", "Yes"], a_zh: ["否", "是"], correct: 0 },
                    { cat: 'logic', level: 2, q_en: "Trees grow from seeds?", q_zh: "树从种子长出来吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 2, q_en: "Fire is cold?", q_zh: "火是冷的吗？", a_en: ["No", "Yes"], a_zh: ["否", "是"], correct: 0 },
                    
                    { cat: 'math', level: 2, q_en: "12 + 8 = ?", q_zh: "12 + 8 = ?", a_en: ["20", "18", "22", "19"], a_zh: ["20", "18", "22", "19"], correct: 0 },
                    { cat: 'math', level: 2, q_en: "15 - 7 = ?", q_zh: "15 - 7 = ?", a_en: ["8", "7", "9", "6"], a_zh: ["8", "7", "9", "6"], correct: 0 },
                    { cat: 'math', level: 2, q_en: "25 + 15 = ?", q_zh: "25 + 15 = ?", a_en: ["40", "35", "45", "50"], a_zh: ["40", "35", "45", "50"], correct: 0 },
                    { cat: 'math', level: 2, q_en: "30 - 18 = ?", q_zh: "30 - 18 = ?", a_en: ["12", "10", "14", "16"], a_zh: ["12", "10", "14", "16"], correct: 0 },
                    { cat: 'math', level: 2, q_en: "17 + 23 = ?", q_zh: "17 + 23 = ?", a_en: ["40", "38", "42", "44"], a_zh: ["40", "38", "42", "44"], correct: 0 },
                    { cat: 'math', level: 2, q_en: "50 - 22 = ?", q_zh: "50 - 22 = ?", a_en: ["28", "26", "30", "32"], a_zh: ["28", "26", "30", "32"], correct: 0 },
                    { cat: 'math', level: 2, q_en: "33 + 27 = ?", q_zh: "33 + 27 = ?", a_en: ["60", "58", "62", "56"], a_zh: ["60", "58", "62", "56"], correct: 0 },
                    
                    // ===== Level 3: 中级题 (30题) =====
                    { cat: 'semantic', level: 3, q_en: "Which is not a room: Kitchen, Bedroom, Garden, Bathroom?", q_zh: "哪个不是房间：厨房、卧室、花园、浴室？", a_en: ["Kitchen", "Bedroom", "Garden", "Bathroom"], a_zh: ["厨房", "卧室", "花园", "浴室"], correct: 2 },
                    { cat: 'semantic', level: 3, q_en: "Odd weather: Sunny, Rainy, Monday, Snowy?", q_zh: "找出不同：晴天、雨天、星期一、雪天？", a_en: ["Sunny", "Rainy", "Monday", "Snowy"], a_zh: ["晴天", "雨天", "星期一", "雪天"], correct: 2 },
                    { cat: 'semantic', level: 3, q_en: "Odd insect: Ant, Bee, Spider, Butterfly?", q_zh: "找出不同：蚂蚁、蜜蜂、蜘蛛、蝴蝶？", a_en: ["Ant", "Bee", "Spider", "Butterfly"], a_zh: ["蚂蚁", "蜜蜂", "蜘蛛", "蝴蝶"], correct: 2 },
                    { cat: 'semantic', level: 3, q_en: "Which is not a grain: Rice, Wheat, Potato, Corn?", q_zh: "哪个不是谷物：大米、小麦、土豆、玉米？", a_en: ["Rice", "Wheat", "Potato", "Corn"], a_zh: ["大米", "小麦", "土豆", "玉米"], correct: 2 },
                    { cat: 'semantic', level: 3, q_en: "Odd sport: Soccer, Basketball, Chess, Tennis?", q_zh: "找出不同：足球、篮球、国际象棋、网球？", a_en: ["Soccer", "Basketball", "Chess", "Tennis"], a_zh: ["足球", "篮球", "国际象棋", "网球"], correct: 2 },
                    { cat: 'semantic', level: 3, q_en: "Which is not stationery: Pen, Paper, Book, Eraser?", q_zh: "哪个不是文具：笔、纸、书、橡皮？", a_en: ["Pen", "Paper", "Book", "Eraser"], a_zh: ["笔", "纸", "书", "橡皮"], correct: 2 },
                    
                    { cat: 'association', level: 3, q_en: "Garden makes you think of:", q_zh: "花园让你想到：", a_en: ["Flowers", "Computer", "Airplane", "Money"], a_zh: ["花朵", "电脑", "飞机", "钱"], correct: 0 },
                    { cat: 'association', level: 3, q_en: "Fire is associated with:", q_zh: "火关联到：", a_en: ["Heat", "Cold", "Wet", "Soft"], a_zh: ["热", "冷", "湿", "软"], correct: 0 },
                    { cat: 'association', level: 3, q_en: "Forest makes you think of:", q_zh: "森林让你想到：", a_en: ["Trees", "Building", "Ocean", "Desert"], a_zh: ["树木", "建筑", "海洋", "沙漠"], correct: 0 },
                    { cat: 'association', level: 3, q_en: "Summer is related to:", q_zh: "夏天关联到：", a_en: ["Hot", "Cold", "Frozen", "Icy"], a_zh: ["热", "冷", "冰冻", "结冰"], correct: 0 },
                    
                    { cat: 'antonym', level: 3, q_en: "Opposite of 'Fast':", q_zh: "'快'的反义词：", a_en: ["Slow", "Quick", "Rapid", "Swift"], a_zh: ["慢", "快速", "迅速", "敏捷"], correct: 0 },
                    { cat: 'synonym', level: 3, q_en: "Similar to 'Happy':", q_zh: "'快乐'的近义词：", a_en: ["Joyful", "Sad", "Angry", "Scared"], a_zh: ["高兴", "悲伤", "愤怒", "害怕"], correct: 0 },
                    { cat: 'antonym', level: 3, q_en: "Opposite of 'Strong':", q_zh: "'强壮'的反义词：", a_en: ["Weak", "Powerful", "Mighty", "Robust"], a_zh: ["虚弱", "强大", "有力", "健壮"], correct: 0 },
                    { cat: 'synonym', level: 3, q_en: "Similar to 'Beautiful':", q_zh: "'美丽'的近义词：", a_en: ["Pretty", "Ugly", "Plain", "Dull"], a_zh: ["漂亮", "丑陋", "朴素", "乏味"], correct: 0 },
                    
                    { cat: 'logic', level: 3, q_en: "Elephants are bigger than mice?", q_zh: "大象比老鼠大吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 3, q_en: "Water flows upward?", q_zh: "水会往上流吗？", a_en: ["No", "Yes"], a_zh: ["否", "是"], correct: 0 },
                    { cat: 'logic', level: 3, q_en: "Penguins can swim?", q_zh: "企鹅会游泳吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 3, q_en: "Shoes go on hands?", q_zh: "鞋子穿在手上吗？", a_en: ["No", "Yes"], a_zh: ["否", "是"], correct: 0 },
                    
                    { cat: 'math', level: 3, q_en: "3 × 2 = ?", q_zh: "3 × 2 = ?", a_en: ["6", "5", "7", "8"], a_zh: ["6", "5", "7", "8"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "10 ÷ 2 = ?", q_zh: "10 ÷ 2 = ?", a_en: ["5", "4", "6", "7"], a_zh: ["5", "4", "6", "7"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "4 × 3 = ?", q_zh: "4 × 3 = ?", a_en: ["12", "10", "14", "16"], a_zh: ["12", "10", "14", "16"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "20 ÷ 4 = ?", q_zh: "20 ÷ 4 = ?", a_en: ["5", "4", "6", "7"], a_zh: ["5", "4", "6", "7"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "6 × 5 = ?", q_zh: "6 × 5 = ?", a_en: ["30", "25", "35", "40"], a_zh: ["30", "25", "35", "40"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "18 ÷ 3 = ?", q_zh: "18 ÷ 3 = ?", a_en: ["6", "5", "7", "8"], a_zh: ["6", "5", "7", "8"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "7 × 8 = ?", q_zh: "7 × 8 = ?", a_en: ["56", "54", "58", "60"], a_zh: ["56", "54", "58", "60"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "36 ÷ 6 = ?", q_zh: "36 ÷ 6 = ?", a_en: ["6", "5", "7", "8"], a_zh: ["6", "5", "7", "8"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "9 × 4 = ?", q_zh: "9 × 4 = ?", a_en: ["36", "32", "40", "44"], a_zh: ["36", "32", "40", "44"], correct: 0 },
                    { cat: 'math', level: 3, q_en: "8 × 6 = ?", q_zh: "8 × 6 = ?", a_en: ["48", "42", "54", "60"], a_zh: ["48", "42", "54", "60"], correct: 0 },
                    
                    // ===== Level 4: 高级题 (25题) =====
                    { cat: 'semantic', level: 4, q_en: "Odd shape: Circle, Square, Heavy, Triangle?", q_zh: "找出不同：圆形、正方形、重的、三角形？", a_en: ["Circle", "Square", "Heavy", "Triangle"], a_zh: ["圆形", "正方形", "重的", "三角形"], correct: 2 },
                    { cat: 'semantic', level: 4, q_en: "Odd natural element: Mountain, River, Building, Forest?", q_zh: "找出不同：山、河、建筑、森林？", a_en: ["Mountain", "River", "Building", "Forest"], a_zh: ["山", "河", "建筑", "森林"], correct: 2 },
                    { cat: 'semantic', level: 4, q_en: "Odd body part: Hand, Foot, Heart, Hair?", q_zh: "找出不同：手、脚、心脏、头发？", a_en: ["Hand", "Foot", "Heart", "Hair"], a_zh: ["手", "脚", "心脏", "头发"], correct: 2 },
                    { cat: 'semantic', level: 4, q_en: "Odd emotion: Happy, Sad, Thinking, Angry?", q_zh: "找出不同：快乐、悲伤、思考、愤怒？", a_en: ["Happy", "Sad", "Thinking", "Angry"], a_zh: ["快乐", "悲伤", "思考", "愤怒"], correct: 2 },
                    
                    { cat: 'association', level: 4, q_en: "Sunrise is related to:", q_zh: "日出关联到：", a_en: ["Morning", "Night", "Midnight", "Evening"], a_zh: ["早晨", "夜晚", "午夜", "傍晚"], correct: 0 },
                    { cat: 'association', level: 4, q_en: "Wedding is connected to:", q_zh: "婚礼关联到：", a_en: ["Marriage", "Funeral", "Battle", "Storm"], a_zh: ["婚姻", "葬礼", "战斗", "风暴"], correct: 0 },
                    { cat: 'association', level: 4, q_en: "Clock makes you think of:", q_zh: "时钟让你想到：", a_en: ["Time", "Color", "Taste", "Smell"], a_zh: ["时间", "颜色", "味道", "气味"], correct: 0 },
                    { cat: 'association', level: 4, q_en: "Telephone is connected to:", q_zh: "电话关联到：", a_en: ["Call", "Write", "Draw", "Build"], a_zh: ["通话", "写字", "画画", "建造"], correct: 0 },
                    
                    { cat: 'synonym', level: 4, q_en: "Similar to 'Smart':", q_zh: "'聪明'的近义词：", a_en: ["Intelligent", "Stupid", "Dumb", "Slow"], a_zh: ["智慧", "愚蠢", "笨", "迟钝"], correct: 0 },
                    { cat: 'antonym', level: 4, q_en: "Opposite of 'Clean':", q_zh: "'干净'的反义词：", a_en: ["Dirty", "Pure", "Fresh", "Clear"], a_zh: ["脏", "纯净", "新鲜", "清澈"], correct: 0 },
                    { cat: 'synonym', level: 4, q_en: "Similar to 'Loud':", q_zh: "'大声'的近义词：", a_en: ["Noisy", "Quiet", "Silent", "Soft"], a_zh: ["吵闹", "安静", "寂静", "轻柔"], correct: 0 },
                    { cat: 'antonym', level: 4, q_en: "Opposite of 'Empty':", q_zh: "'空'的反义词：", a_en: ["Full", "Vacant", "Hollow", "Bare"], a_zh: ["满", "空缺", "空洞", "光秃"], correct: 0 },
                    
                    { cat: 'logic', level: 4, q_en: "Night comes after day?", q_zh: "夜晚在白天之后吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 4, q_en: "Books are for reading?", q_zh: "书是用来阅读的吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 4, q_en: "Chairs are for sitting?", q_zh: "椅子是用来坐的吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    { cat: 'logic', level: 4, q_en: "Clouds are in the sky?", q_zh: "云在天空中吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    
                    { cat: 'math', level: 4, q_en: "3 × 4 + 5 = ?", q_zh: "3 × 4 + 5 = ?", a_en: ["17", "15", "19", "20"], a_zh: ["17", "15", "19", "20"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "20 - 6 × 2 = ?", q_zh: "20 - 6 × 2 = ?", a_en: ["8", "6", "10", "12"], a_zh: ["8", "6", "10", "12"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "15 ÷ 3 + 8 = ?", q_zh: "15 ÷ 3 + 8 = ?", a_en: ["13", "11", "15", "17"], a_zh: ["13", "11", "15", "17"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "(12 + 8) ÷ 4 = ?", q_zh: "(12 + 8) ÷ 4 = ?", a_en: ["5", "4", "6", "7"], a_zh: ["5", "4", "6", "7"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "25 - 3 × 5 = ?", q_zh: "25 - 3 × 5 = ?", a_en: ["10", "8", "12", "15"], a_zh: ["10", "8", "12", "15"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "40 ÷ 8 + 12 = ?", q_zh: "40 ÷ 8 + 12 = ?", a_en: ["17", "15", "19", "20"], a_zh: ["17", "15", "19", "20"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "6 × (9 - 4) = ?", q_zh: "6 × (9 - 4) = ?", a_en: ["30", "25", "35", "40"], a_zh: ["30", "25", "35", "40"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "50 - 18 ÷ 3 = ?", q_zh: "50 - 18 ÷ 3 = ?", a_en: ["44", "42", "46", "48"], a_zh: ["44", "42", "46", "48"], correct: 0 },
                    { cat: 'math', level: 4, q_en: "8 × 3 - 10 = ?", q_zh: "8 × 3 - 10 = ?", a_en: ["14", "12", "16", "18"], a_zh: ["14", "12", "16", "18"], correct: 0 },
                    
                    // ===== Level 5: 专家题 (20题) =====
                    { cat: 'semantic', level: 5, q_en: "Which is not kitchenware: Pot, Pan, Television, Spoon?", q_zh: "哪个不是厨具：锅、平底锅、电视、勺子？", a_en: ["Pot", "Pan", "Television", "Spoon"], a_zh: ["锅", "平底锅", "电视", "勺子"], correct: 2 },
                    
                    { cat: 'association', level: 5, q_en: "Cinema is associated with:", q_zh: "电影院关联到：", a_en: ["Movie", "Grocery", "Hospital", "Bank"], a_zh: ["电影", "杂货", "医院", "银行"], correct: 0 },
                    { cat: 'association', level: 5, q_en: "Bed reminds you of:", q_zh: "床让你想起：", a_en: ["Sleep", "Run", "Dance", "Swim"], a_zh: ["睡觉", "跑步", "跳舞", "游泳"], correct: 0 },
                    { cat: 'association', level: 5, q_en: "Newspaper reminds you of:", q_zh: "报纸让你想起：", a_en: ["News", "Food", "Clothes", "Furniture"], a_zh: ["新闻", "食物", "衣服", "家具"], correct: 0 },
                    { cat: 'association', level: 5, q_en: "Church is connected to:", q_zh: "教堂关联到：", a_en: ["Prayer", "Shopping", "Gaming", "Cooking"], a_zh: ["祈祷", "购物", "游戏", "烹饪"], correct: 0 },
                    { cat: 'association', level: 5, q_en: "Rainbow makes you think of:", q_zh: "彩虹让你想到：", a_en: ["Colors", "Black", "Night", "Darkness"], a_zh: ["颜色", "黑色", "夜晚", "黑暗"], correct: 0 },
                    
                    { cat: 'antonym', level: 5, q_en: "Opposite of 'Day':", q_zh: "'白天'的反义词：", a_en: ["Night", "Morning", "Noon", "Afternoon"], a_zh: ["夜晚", "早晨", "中午", "下午"], correct: 0 },
                    { cat: 'synonym', level: 5, q_en: "Similar to 'Small':", q_zh: "'小'的近义词：", a_en: ["Tiny", "Big", "Large", "Huge"], a_zh: ["微小", "大", "巨大", "庞大"], correct: 0 },
                    { cat: 'synonym', level: 5, q_en: "Similar to 'Brave':", q_zh: "'勇敢'的近义词：", a_en: ["Courageous", "Cowardly", "Timid", "Fearful"], a_zh: ["英勇", "胆小", "胆怯", "害怕"], correct: 0 },
                    
                    { cat: 'logic', level: 5, q_en: "Rain makes things wet?", q_zh: "雨会让东西变湿吗？", a_en: ["Yes", "No"], a_zh: ["是", "否"], correct: 0 },
                    
                    { cat: 'math', level: 5, q_en: "(15 + 25) × 2 = ?", q_zh: "(15 + 25) × 2 = ?", a_en: ["80", "70", "90", "100"], a_zh: ["80", "70", "90", "100"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "100 - 12 × 5 = ?", q_zh: "100 - 12 × 5 = ?", a_en: ["40", "30", "50", "60"], a_zh: ["40", "30", "50", "60"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "72 ÷ (3 + 5) = ?", q_zh: "72 ÷ (3 + 5) = ?", a_en: ["9", "8", "10", "11"], a_zh: ["9", "8", "10", "11"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "8 × 7 - 3 × 9 = ?", q_zh: "8 × 7 - 3 × 9 = ?", a_en: ["29", "27", "31", "33"], a_zh: ["29", "27", "31", "33"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "120 ÷ 4 + 15 = ?", q_zh: "120 ÷ 4 + 15 = ?", a_en: ["45", "40", "50", "55"], a_zh: ["45", "40", "50", "55"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "(60 - 20) ÷ 8 = ?", q_zh: "(60 - 20) ÷ 8 = ?", a_en: ["5", "4", "6", "7"], a_zh: ["5", "4", "6", "7"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "14 × 5 - 25 = ?", q_zh: "14 × 5 - 25 = ?", a_en: ["45", "40", "50", "55"], a_zh: ["45", "40", "50", "55"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "96 ÷ (4 × 2) = ?", q_zh: "96 ÷ (4 × 2) = ?", a_en: ["12", "10", "14", "16"], a_zh: ["12", "10", "14", "16"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "(25 + 35) ÷ 12 = ?", q_zh: "(25 + 35) ÷ 12 = ?", a_en: ["5", "4", "6", "7"], a_zh: ["5", "4", "6", "7"], correct: 0 },
                    { cat: 'math', level: 5, q_en: "11 × 9 - 48 = ?", q_zh: "11 × 9 - 48 = ?", a_en: ["51", "49", "53", "55"], a_zh: ["51", "49", "53", "55"], correct: 0 },
                ];
                
                // ========== ENHANCED DIFFICULTY SYSTEM ==========
                this.difficultySystem = {
                    currentLevel: 2,
                    consecutiveCorrect: 0,
                    consecutiveWrong: 0,
                    upgradeThreshold: 5,
                    downgradeThreshold: 3,
                    
                    recordAnswer: function(isCorrect) {
                        if (isCorrect) {
                            this.consecutiveCorrect++;
                            this.consecutiveWrong = 0;
                            if (this.consecutiveCorrect >= this.upgradeThreshold && this.currentLevel < 5) {
                                this.currentLevel++;
                                this.consecutiveCorrect = 0;
                                return 'upgrade';
                            }
                        } else {
                            this.consecutiveWrong++;
                            this.consecutiveCorrect = 0;
                            if (this.consecutiveWrong >= this.downgradeThreshold && this.currentLevel > 1) {
                                this.currentLevel--;
                                this.consecutiveWrong = 0;
                                return 'downgrade';
                            }
                        }
                        return 'same';
                    },
                    
                    getLevel: function() { return this.currentLevel; },
                    
                    getProgress: function() {
                        return {
                            level: this.currentLevel,
                            correctStreak: this.consecutiveCorrect,
                            wrongStreak: this.consecutiveWrong
                        };
                    }
                };
                
                // ========== EVENT LISTENERS ==========
                this.onDown = (e) => {
                    if (this.phase !== 'breathing') return;
                    const isTouch = e.type === 'touchstart';
                    
                    this.isHolding = true;
                    this.holdTime = 0;
                    Sound.play('hover');
                    
                    if (isTouch) e.preventDefault();
                };
                
                this.onUp = (e) => {
                    if (!this.isHolding || this.phase !== 'breathing') return;
                    this.isHolding = false;
                    
                    // 检查与呼吸波峰的匹配度
                    const targetScale = this.getTargetRingScale();
                    const currentScale = this.playerRing.scale.x;
                    const scaleDiff = Math.abs(currentScale - targetScale);
                    const matchQuality = Math.max(0, 1 - scaleDiff * 2);
                    
                    if (matchQuality >= 0.7) {
                        this.triggerPerfectActivation();
                    } else {
                        this.triggerFailedActivation();
                    }
                };
                
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchstart', this.onDown, { passive: false });
                document.addEventListener('touchend', this.onUp);
                document.addEventListener('touchcancel', this.onUp);
                
                console.log('✓ Module 3 Refined initialized');
            }
            
            // ========== VISUAL CREATION ==========
            
            createFrostedGlassRing(baseRadius, color) {
                // 毛玻璃效果的静态目标环
                const points = [];
                const segments = 128;
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    // 细微不规则，营造手工感
                    const irregularity = Math.sin(angle * 13) * 0.008 + Math.cos(angle * 17) * 0.006;
                    const radius = baseRadius + irregularity;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5,
                    linewidth: 3
                });
                
                return new THREE.Line(geometry, material);
            }
            
            createSmoothRing(radius, color) {
                const points = [];
                const segments = 64;
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.0,
                    linewidth: 3
                });
                
                return new THREE.Line(geometry, material);
            }
            
            createDot() {
                const geometry = new THREE.CircleGeometry(0.04, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xc02625,
                    transparent: true,
                    opacity: 0.8
                });
                return new THREE.Mesh(geometry, material);
            }
            
            createNeuralNetwork() {
                const nodeCount = 12;
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * Math.PI * 2;
                    const radius = 2.5 + Math.random() * 0.5;
                    
                    const geometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x2a2a2a,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const neuron = new THREE.Mesh(geometry, material);
                    neuron.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    neuron.userData = { 
                        angle, 
                        baseRadius: radius,
                        phase: Math.random() * Math.PI * 2
                    };
                    
                    this.neurons.push(neuron);
                    this.group.add(neuron);
                }
            }
            
            // ========== INTERACTION ==========
            
            getTargetRingScale() {
                const phase = (this.breathTime % this.breathCycleTime) / this.breathCycleTime;
                const breathCurve = this.easeInOutSine(phase);
                return 0.85 + breathCurve * 0.3; // 0.85-1.15范围
            }
            
            triggerPerfectActivation() {
                console.log('✨ Perfect breath sync!');
                
                const breathHint = document.getElementById('breath-hint');
                if (breathHint) breathHint.classList.remove('active');
                
                Sound.play('click');
                this.createParticleBurst();
                
                setTimeout(() => this.showQuestion(), 300);
            }
            
            triggerFailedActivation() {
                console.log('⚠️ Timing needs adjustment...');
                
                try {
                    if (typeof Tone !== 'undefined') {
                        const synth = new Tone.Synth().toDestination();
                        synth.triggerAttackRelease('C2', '0.1');
                        setTimeout(() => synth.dispose(), 200);
                    }
                } catch(e) {}
                
                this.shakeNetwork();
            }
            
            createParticleBurst() {
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 0.02 + Math.random() * 0.03;
                    
                    const geometry = new THREE.CircleGeometry(0.02, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xc02625,
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(0, 0, 0);
                    particle.userData = {
                        velocity: {
                            x: Math.cos(angle) * speed,
                            y: Math.sin(angle) * speed
                        },
                        life: 1.0,
                        decay: 0.02
                    };
                    
                    this.particles.push(particle);
                    this.group.add(particle);
                }
            }
            
            shakeNetwork() {
                this.neurons.forEach(neuron => {
                    const originalPos = neuron.position.clone();
                    const shakeIntensity = 0.1;
                    
                    const shake = () => {
                        neuron.position.x = originalPos.x + (Math.random() - 0.5) * shakeIntensity;
                        neuron.position.y = originalPos.y + (Math.random() - 0.5) * shakeIntensity;
                    };
                    
                    shake();
                    setTimeout(shake, 50);
                    setTimeout(shake, 100);
                    setTimeout(() => neuron.position.copy(originalPos), 150);
                });
            }
            
            // ========== QUESTION SYSTEM ==========
            
            showQuestion() {
                this.phase = 'answer';
                this.questionStartTime = Date.now();
                
                // 根据当前难度等级选择问题
                const currentLevel = this.difficultySystem.getLevel();
                const availableQuestions = this.questionBank.filter(q => {
                    return !q.level || q.level === currentLevel;
                });
                
                const q = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
                this.currentQuestion = q;
                
                const overlay = document.getElementById('question-overlay');
                const lang = I18N.lang;
                
                document.getElementById('question-text').textContent = lang === 'zh' ? q.q_zh : q.q_en;
                
                const answersContainer = document.getElementById('answer-options');
                if (answersContainer) {
                    answersContainer.innerHTML = '';
                    const answers = lang === 'zh' ? q.a_zh : q.a_en;
                    answers.forEach((answer, i) => {
                        const btn = document.createElement('button');
                        btn.className = 'answer-option';
                        btn.textContent = answer;
                        btn.onclick = () => this.submitAnswer(i);
                        answersContainer.appendChild(btn);
                    });
                }
                
                overlay.classList.add('active');
            }
            
            submitAnswer(index) {
                if (this.phase !== 'answer') return;
                
                const isCorrect = index === this.currentQuestion.correct;
                const levelChange = this.difficultySystem.recordAnswer(isCorrect);
                
                if (isCorrect) {
                    this.score += 10;
                    Sound.play('click');
                } else {
                    try {
                        if (typeof Tone !== 'undefined') {
                            const synth = new Tone.Synth().toDestination();
                            synth.triggerAttackRelease('C2', '0.15');
                            setTimeout(() => synth.dispose(), 200);
                        }
                    } catch(e) {}
                }
                
                // 极简Level Up效果
                if (levelChange === 'upgrade') {
                    this.showMinimalLevelNotification('升级', 'LEVEL UP', 'upgrade');
                } else if (levelChange === 'downgrade') {
                    this.showMinimalLevelNotification('调整', 'ADJUST', 'downgrade');
                }
                
                this.questionCount++;
                document.getElementById('question-overlay').classList.remove('active');
                
                if (this.questionCount >= this.maxQuestions) {
                    GameEngine.complete();
                } else {
                    this.phase = 'breathing';
                    const breathHint = document.getElementById('breath-hint');
                    if (breathHint) breathHint.classList.add('active');
                }
            }
            
            // ========== MINIMAL LEVEL NOTIFICATION (Wabi-sabi + Apple) ==========
            
            showMinimalLevelNotification(textZh, textEn, type) {
                const lang = I18N.lang;
                const message = lang === 'zh' ? textZh : textEn;
                const level = this.difficultySystem.getLevel();
                
                // 极简容器
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 9999;
                    background: rgba(245, 245, 240, 0.85);
                    backdrop-filter: blur(40px);
                    border-radius: 24px;
                    padding: 3rem 4rem;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
                    opacity: 0;
                    pointer-events: none;
                    text-align: center;
                    font-family: -apple-system, 'SF Pro Display', 'Inter', sans-serif;
                    border: 1px solid rgba(255, 255, 255, 0.6);
                `;
                
                // Level数字 - 极简设计
                const levelDisplay = document.createElement('div');
                levelDisplay.style.cssText = `
                    font-size: 5rem;
                    font-weight: 200;
                    color: ${type === 'upgrade' ? '#34C759' : '#c02625'};
                    margin-bottom: 0.5rem;
                    letter-spacing: -0.02em;
                    line-height: 1;
                `;
                levelDisplay.textContent = level;
                
                // 文本提示
                const textDisplay = document.createElement('div');
                textDisplay.style.cssText = `
                    font-size: 0.85rem;
                    font-weight: 400;
                    color: rgba(42, 42, 42, 0.6);
                    letter-spacing: 0.05em;
                    text-transform: uppercase;
                `;
                textDisplay.textContent = message;
                
                // 淡雅的光晕
                const glow = document.createElement('div');
                glow.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 120%;
                    height: 120%;
                    transform: translate(-50%, -50%);
                    background: radial-gradient(circle, ${type === 'upgrade' ? 'rgba(52, 199, 89, 0.15)' : 'rgba(192, 38, 37, 0.15)'} 0%, transparent 70%);
                    border-radius: 50%;
                    pointer-events: none;
                    opacity: 0;
                `;
                
                notification.appendChild(glow);
                notification.appendChild(levelDisplay);
                notification.appendChild(textDisplay);
                document.body.appendChild(notification);
                
                // 淡雅音效
                try {
                    if (typeof Tone !== 'undefined') {
                        const synth = new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: {
                                attack: 0.05,
                                decay: 0.3,
                                sustain: 0.1,
                                release: 0.8
                            }
                        }).toDestination();
                        
                        if (type === 'upgrade') {
                            synth.triggerAttackRelease('C5', '0.4');
                        } else {
                            synth.triggerAttackRelease('G4', '0.3');
                        }
                        setTimeout(() => synth.dispose(), 1200);
                    }
                } catch(e) {}
                
                // 渐显动画
                setTimeout(() => {
                    notification.style.transition = 'all 0.6s cubic-bezier(0.16, 1, 0.3, 1)';
                    notification.style.opacity = '1';
                    glow.style.transition = 'opacity 0.6s ease';
                    glow.style.opacity = '1';
                }, 10);
                
                // 渐隐移除
                setTimeout(() => {
                    notification.style.opacity = '0';
                    glow.style.opacity = '0';
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 600);
                }, 2000);
            }
            
            // ========== UPDATE LOOP ==========
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                // 持续累加时间，保证无缝循环
                this.breathTime += deltaTime;
                
                // 呼吸相位（0到1的循环）
                const phase = (this.breathTime % this.breathCycleTime) / this.breathCycleTime;
                const breathCurve = this.easeInOutSine(phase); // 0到1平滑过渡
                
                // 目标环呼吸（0.85-1.15倍平滑循环）
                const targetScale = 0.85 + breathCurve * 0.3;
                this.targetRing.scale.set(targetScale, targetScale, 1);
                this.targetRing.material.opacity = 0.4 + breathCurve * 0.2;
                
                // 指示点：在呼吸波峰时高亮
                const isPeak = breathCurve > 0.75;
                this.indicatorDots.forEach((dot, i) => {
                    const angle = dot.userData.angle + this.breathTime * 0.2;
                    const radius = dot.userData.baseRadius * targetScale;
                    
                    dot.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    
                    dot.material.opacity = isPeak ? 0.95 : 0.5;
                    const dotScale = isPeak ? 1.4 : 0.9;
                    dot.scale.set(dotScale, dotScale, 1);
                });
                
                // 神经网络节点
                this.neurons.forEach(neuron => {
                    const phase = neuron.userData.phase + this.breathTime * 2;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const scale = 0.7 + pulse * 0.3 + breathCurve * 0.2;
                    neuron.scale.set(scale, scale, scale);
                    neuron.material.opacity = 0.2 + pulse * 0.2 + breathCurve * 0.1;
                });
                
                // 按住交互：玩家环跟随呼吸
                if (this.isHolding && this.phase === 'breathing') {
                    this.holdTime += deltaTime;
                    
                    // 玩家环跟随目标环的呼吸节奏
                    this.playerRing.scale.set(targetScale, targetScale, 1);
                    this.playerRing.material.opacity = 0.8;
                    
                    // 检测匹配
                    const scaleDiff = Math.abs(targetScale - targetScale); // 总是0，因为同步
                    const isMatched = isPeak; // 在波峰时才算匹配
                    
                    if (isMatched) {
                        this.matchRing.scale.set(targetScale, targetScale, 1);
                        this.matchRing.material.opacity = 0.8;
                        this.playerRing.material.color.setHex(0x00cc00);
                        
                        const peakIndicator = document.getElementById('peak-indicator');
                        if (peakIndicator) peakIndicator.classList.add('active');
                    } else {
                        this.playerRing.material.color.setHex(0x2a2a2a);
                        this.matchRing.material.opacity = 0;
                        
                        const peakIndicator = document.getElementById('peak-indicator');
                        if (peakIndicator) peakIndicator.classList.remove('active');
                    }
                } else {
                    // 松开后淡出
                    this.playerRing.material.opacity = Math.max(0, this.playerRing.material.opacity - deltaTime * 3);
                    if (this.playerRing.material.opacity <= 0) {
                        this.playerRing.scale.set(0, 0, 1);
                    }
                    
                    this.matchRing.material.opacity = Math.max(0, this.matchRing.material.opacity - deltaTime * 3);
                    if (this.matchRing.material.opacity <= 0) {
                        this.matchRing.scale.set(0, 0, 1);
                    }
                    
                    const peakIndicator = document.getElementById('peak-indicator');
                    if (peakIndicator) peakIndicator.classList.remove('active');
                }
                
                // 粒子更新
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.position.x += particle.userData.velocity.x;
                    particle.position.y += particle.userData.velocity.y;
                    particle.userData.life -= particle.userData.decay;
                    particle.material.opacity = particle.userData.life;
                    
                    if (particle.userData.life <= 0) {
                        this.group.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        this.particles.splice(i, 1);
                    }
                }
                
                // 整体旋转
                this.group.rotation.z += deltaTime * 0.05;
                
                // 更新UI
                stats.score = this.score;
                stats.progress = (this.questionCount / this.maxQuestions) * 100;
                
                const difficultyDisplay = document.getElementById('difficulty-display');
                if (difficultyDisplay) {
                    difficultyDisplay.style.display = 'block';
                    const progress = this.difficultySystem.getProgress();
                    const levelEl = document.getElementById('current-level');
                    const correctEl = document.getElementById('streak-correct');
                    const wrongEl = document.getElementById('streak-wrong');
                    if (levelEl) levelEl.textContent = progress.level;
                    if (correctEl) correctEl.textContent = `✓ Streak: ${progress.correctStreak}/5`;
                    if (wrongEl) wrongEl.textContent = `✗ Streak: ${progress.wrongStreak}/3`;
                }
            }
            
            easeInOutSine(x) {
                // 完美的0到1再到0的平滑曲线
                return -(Math.cos(Math.PI * x) - 1) / 2;
            }
            
            // ========== CLEANUP ==========
            
            cleanup() {
                console.log('🧹 Cleaning up Module 3...');
                this.isActive = false;
                
                const breathHint = document.getElementById('breath-hint');
                if (breathHint) breathHint.classList.remove('active');
                const peakIndicator = document.getElementById('peak-indicator');
                if (peakIndicator) peakIndicator.classList.remove('active');
                const difficultyDisplay = document.getElementById('difficulty-display');
                if (difficultyDisplay) difficultyDisplay.style.display = 'none';
                
                // 清理问题overlay
                const questionOverlay = document.getElementById('question-overlay');
                if (questionOverlay) {
                    questionOverlay.style.opacity = '0';
                    questionOverlay.style.display = 'none';
                }
                
                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('touchend', this.onUp);
                document.removeEventListener('touchcancel', this.onUp);
                
                if (Visual.scene && this.group) {
                    this.group.traverse(obj => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    });
                    Visual.scene.remove(this.group);
                }
                
                console.log('✓ Module 3 cleaned up');
            }
        }

        class Module4 {
            init() {
                console.log('〰️ Module 4 initializing - Vintage Radio Tuner...');
                this.isActive = true;
                this.canvas = document.getElementById('mod4-canvas');
                this.canvas.style.display = 'block';
                
                // Full screen canvas
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx = this.canvas.getContext('2d');
                
                this.resizeHandler = PerformanceUtils.throttle(() => this.resize(), 250);
                window.addEventListener('resize', this.resizeHandler);
                
                const difficulty = App.tOC;
                this.currentStage = 0;
                this.totalStages = 3 + Math.floor(difficulty / 30);
                
                // User controls
                this.userFreq = 0.5; // 0-1 normalized
                this.userAmp = 0.5;  // 0-1 normalized
                
                // Static noise for radio effect
                this.staticNoise = [];
                for (let i = 0; i < 800; i++) {
                    this.staticNoise.push({
                        x: Math.random(),
                        y: Math.random(),
                        alpha: Math.random() * 0.2
                    });
                }
                
                // Generate artistic target waves with various types
                this.targetWaves = [];
                const waveTypes = ['sine', 'complex', 'modulated', 'harmonic'];
                for (let i = 0; i < this.totalStages; i++) {
                    this.targetWaves.push({
                        type: waveTypes[Math.floor(Math.random() * waveTypes.length)],
                        freq: 0.3 + Math.random() * 0.7,  // normalized 0-1
                        amp: 0.3 + Math.random() * 0.6,   // normalized 0-1
                        phase: Math.random() * Math.PI * 2,
                        harmonics: Math.random() > 0.5 ? 2 : 1,
                        modDepth: 0.2 + Math.random() * 0.3
                    });
                }
                
                // Visual effects parameters
                this.particles = [];
                this.gridAlpha = 0.03;
                this.time = 0;
                
                this.createControls();
                console.log('✓ Module 4 initialized - Vintage Radio Style');
            }
            
            resize() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            createControls() {
                const isMobile = window.innerWidth < 768;
                
                const controlDiv = document.createElement('div');
                controlDiv.id = 'wave-controls';
                
                // 艺术化控制面板设计
                if (isMobile) {
                    // 手机：两个旋钮都在底部，横向排列
                    controlDiv.style.cssText = `
                        position: fixed;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        pointer-events: none;
                        z-index: 100;
                        display: flex;
                        justify-content: center;
                        align-items: flex-end;
                        padding-bottom: 1.5rem;
                    `;
                    
                    // 容器：横向布局
                    const knobContainer = document.createElement('div');
                    knobContainer.style.cssText = `
                        display: flex;
                        gap: 2rem;
                        align-items: center;
                        pointer-events: auto;
                        background: rgba(245, 245, 240, 0.95);
                        padding: 1.2rem 1.8rem;
                        border-radius: 20px;
                        border: 2px solid rgba(192, 38, 37, 0.3);
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
                        backdrop-filter: blur(10px);
                    `;
                    
                    const tuneKnob = this.createArtisticKnob('TUNE', true);
                    const volumeKnob = this.createArtisticKnob('VOLUME', false);
                    
                    knobContainer.appendChild(tuneKnob);
                    knobContainer.appendChild(volumeKnob);
                    controlDiv.appendChild(knobContainer);
                    
                    // CHECK按钮放在右下角
                    const checkBtn = document.createElement('button');
                    checkBtn.className = 'btn accent';
                    checkBtn.textContent = 'CHECK';
                    checkBtn.style.cssText = `
                        position: fixed;
                        bottom: 1.5rem;
                        right: 1rem;
                        padding: 0.9rem 1.8rem;
                        font-size: 0.7rem;
                        letter-spacing: 0.2em;
                        pointer-events: auto;
                        background: rgba(192, 38, 37, 0.95);
                        border: 2px solid rgba(42, 42, 42, 0.2);
                        color: #f5f5f0;
                        box-shadow: 0 6px 20px rgba(192, 38, 37, 0.35);
                        border-radius: 8px;
                        font-weight: 500;
                    `;
                    checkBtn.addEventListener('click', () => this.checkMatch());
                    controlDiv.appendChild(checkBtn);
                    
                } else {
                    // 桌面：右侧精致面板
                    controlDiv.style.cssText = `
                        position: absolute;
                        right: 2.5rem;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 260px;
                        background: rgba(245, 245, 240, 0.98);
                        padding: 2.5rem 2rem;
                        border: 2px solid rgba(192, 38, 37, 0.4);
                        border-radius: 20px;
                        box-shadow: 
                            0 12px 48px rgba(0, 0, 0, 0.18),
                            inset 0 2px 0 rgba(255, 255, 255, 0.6);
                        backdrop-filter: blur(10px);
                    `;
                    
                    const tuneKnob = this.createArtisticKnob('TUNE', true);
                    tuneKnob.style.marginBottom = '2.5rem';
                    controlDiv.appendChild(tuneKnob);
                    
                    const volumeKnob = this.createArtisticKnob('VOLUME', false);
                    volumeKnob.style.marginBottom = '2rem';
                    controlDiv.appendChild(volumeKnob);
                    
                    const checkBtn = document.createElement('button');
                    checkBtn.className = 'btn accent';
                    checkBtn.textContent = 'CHECK SIGNAL';
                    checkBtn.style.cssText = `
                        width: 100%;
                        font-size: 0.7rem;
                        letter-spacing: 0.15em;
                        padding: 1rem;
                        background: rgba(192, 38, 37, 0.95);
                        border: 2px solid rgba(42, 42, 42, 0.2);
                        color: #f5f5f0;
                        box-shadow: 
                            0 4px 16px rgba(192, 38, 37, 0.3),
                            inset 0 -2px 8px rgba(0, 0, 0, 0.2);
                        border-radius: 8px;
                        font-weight: 500;
                    `;
                    checkBtn.addEventListener('click', () => this.checkMatch());
                    controlDiv.appendChild(checkBtn);
                }
                
                this.controlDiv = controlDiv;
                document.getElementById('game-screen').appendChild(controlDiv);
            }
            
            createArtisticKnob(label, isFrequency) {
                const container = document.createElement('div');
                container.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    position: relative;
                `;
                
                // 标签
                const labelEl = document.createElement('div');
                labelEl.textContent = label;
                labelEl.style.cssText = `
                    font-size: 0.6rem;
                    letter-spacing: 0.25em;
                    color: rgba(42, 42, 42, 0.7);
                    margin-bottom: 1rem;
                    font-weight: 600;
                    text-transform: uppercase;
                `;
                container.appendChild(labelEl);
                
                // 旋钮外圈 - 艺术化设计
                const knobOuter = document.createElement('div');
                knobOuter.style.cssText = `
                    width: 100px;
                    height: 100px;
                    border-radius: 50%;
                    background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.9), rgba(245, 245, 240, 0.95));
                    box-shadow: 
                        0 8px 24px rgba(0, 0, 0, 0.15),
                        inset 0 -4px 12px rgba(0, 0, 0, 0.1),
                        inset 0 4px 12px rgba(255, 255, 255, 0.8);
                    position: relative;
                    cursor: grab;
                    transition: transform 0.05s ease-out, box-shadow 0.2s ease;
                    border: 3px solid rgba(192, 38, 37, 0.2);
                `;
                
                // 悬停效果
                knobOuter.addEventListener('mouseenter', () => {
                    knobOuter.style.boxShadow = `
                        0 10px 32px rgba(192, 38, 37, 0.25),
                        inset 0 -4px 12px rgba(0, 0, 0, 0.1),
                        inset 0 4px 12px rgba(255, 255, 255, 0.8)
                    `;
                });
                knobOuter.addEventListener('mouseleave', () => {
                    knobOuter.style.boxShadow = `
                        0 8px 24px rgba(0, 0, 0, 0.15),
                        inset 0 -4px 12px rgba(0, 0, 0, 0.1),
                        inset 0 4px 12px rgba(255, 255, 255, 0.8)
                    `;
                });
                
                // 刻度圈 - 艺术化刻度
                const scaleRing = document.createElement('div');
                scaleRing.style.cssText = `
                    position: absolute;
                    top: -8px;
                    left: -8px;
                    right: -8px;
                    bottom: -8px;
                    border-radius: 50%;
                `;
                
                // 绘制刻度线（12个）
                for (let i = 0; i < 12; i++) {
                    const tick = document.createElement('div');
                    const angle = (i * 30) - 90; // -90 to start from top
                    const isMainTick = i % 3 === 0;
                    
                    tick.style.cssText = `
                        position: absolute;
                        width: ${isMainTick ? '3px' : '2px'};
                        height: ${isMainTick ? '12px' : '8px'};
                        background: linear-gradient(to bottom, 
                            ${isMainTick ? 'rgba(192, 38, 37, 0.8)' : 'rgba(42, 42, 42, 0.4)'}, 
                            transparent);
                        top: 0;
                        left: 50%;
                        transform-origin: center ${50 + 8}px;
                        transform: translateX(-50%) rotate(${angle}deg);
                        border-radius: 2px;
                    `;
                    scaleRing.appendChild(tick);
                }
                knobOuter.appendChild(scaleRing);
                
                // 旋钮指示器 - 更艺术化
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: absolute;
                    top: 12px;
                    left: 50%;
                    width: 4px;
                    height: 28px;
                    background: linear-gradient(to bottom, 
                        #c02625, 
                        rgba(192, 38, 37, 0.7));
                    transform: translateX(-50%);
                    border-radius: 2px;
                    box-shadow: 
                        0 0 12px rgba(192, 38, 37, 0.8),
                        0 2px 6px rgba(0, 0, 0, 0.3);
                `;
                knobOuter.appendChild(indicator);
                
                // 中心装饰 - 艺术化圆形
                const centerCircle = document.createElement('div');
                centerCircle.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 30px;
                    height: 30px;
                    background: radial-gradient(circle at 35% 35%, 
                        rgba(255, 255, 255, 0.9), 
                        rgba(192, 38, 37, 0.15));
                    border: 2px solid rgba(192, 38, 37, 0.3);
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    box-shadow: 
                        0 2px 8px rgba(0, 0, 0, 0.15),
                        inset 0 2px 4px rgba(0, 0, 0, 0.1);
                `;
                knobOuter.appendChild(centerCircle);
                
                // 中心点
                const centerDot = document.createElement('div');
                centerDot.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 8px;
                    height: 8px;
                    background: #2a2a2a;
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6);
                `;
                knobOuter.appendChild(centerDot);
                
                container.appendChild(knobOuter);
                
                // 滑块（隐藏）
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = '0';
                slider.max = '100';
                slider.value = '50';
                slider.style.cssText = 'opacity: 0; position: absolute; width: 1px; height: 1px;';
                
                let rotation = 0;
                const updateKnob = (value) => {
                    rotation = (value - 50) * 2.7; // -135deg to +135deg
                    knobOuter.style.transform = `rotate(${rotation}deg)`;
                    
                    if (isFrequency) {
                        this.userFreq = value / 100;
                        this.freqSlider = slider;
                    } else {
                        this.userAmp = value / 100;
                        this.ampSlider = slider;
                    }
                };
                
                slider.addEventListener('input', (e) => {
                    updateKnob(parseFloat(e.target.value));
                });
                
                // 鼠标/触摸控制旋钮
                let isDragging = false;
                let startY = 0;
                let startValue = 50;
                
                const onStart = (e) => {
                    isDragging = true;
                    startY = e.clientY || e.touches[0].clientY;
                    startValue = parseFloat(slider.value);
                    knobOuter.style.cursor = 'grabbing';
                    e.preventDefault();
                };
                
                const onMove = (e) => {
                    if (!isDragging) return;
                    const currentY = e.clientY || (e.touches && e.touches[0].clientY);
                    const deltaY = startY - currentY;
                    const newValue = Math.max(0, Math.min(100, startValue + deltaY * 0.4));
                    slider.value = newValue;
                    updateKnob(newValue);
                    e.preventDefault();
                };
                
                const onEnd = () => {
                    isDragging = false;
                    knobOuter.style.cursor = 'grab';
                };
                
                knobOuter.addEventListener('mousedown', onStart);
                knobOuter.addEventListener('touchstart', onStart, { passive: false });
                document.addEventListener('mousemove', onMove);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchend', onEnd);
                
                container.appendChild(slider);
                
                return container;
            }
            
            checkMatch() {
                const target = this.targetWaves[this.currentStage];
                const freqDiff = Math.abs(this.userFreq - target.freq);
                const ampDiff = Math.abs(this.userAmp - target.amp);
                
                // 更严格的容错空间 - 从0.22降低到0.12
                if (freqDiff < 0.12 && ampDiff < 0.12) {
                    Sound.play('success');
                    GameEngine.stats.score += 20;
                    this.currentStage++;
                    
                    // Cycle back to first stage for continuous play
                    if (this.currentStage >= this.totalStages) {
                        this.currentStage = 0;
                    }
                    
                    // Reset sliders for new wave
                    this.userFreq = 0.5;
                    this.userAmp = 0.5;
                    this.freqSlider.value = '50';
                    this.ampSlider.value = '50';
                    
                    // Visual feedback
                    this.spawnSuccessParticles();
                } else {
                    Sound.play('click', 'C2', 0.5);
                    GameEngine.stats.errors++;
                }
            }
            
            spawnSuccessParticles() {
                // Create particle burst on success
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    this.particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 1.0,
                        color: '#00ff00'
                    });
                }
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                this.time += deltaTime;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // === 主题浅色背景 ===
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, w, h);
                
                // === 艺术化网格 ===
                this.drawArtisticGrid(ctx, w, h);
                
                // === Update and draw particles ===
                this.updateParticles(ctx, deltaTime);
                
                const target = this.targetWaves[this.currentStage];
                
                // === Draw Target Wave (top third - 主题红色) ===
                const targetY = h * 0.3;
                this.drawArtisticWave(ctx, w, h, target, targetY, '#c02625', true);
                
                // === Draw User Wave (bottom third - 黑色) ===
                const userY = h * 0.7;
                const userWave = {
                    type: 'sine',
                    freq: this.userFreq,
                    amp: this.userAmp,
                    phase: 0,
                    harmonics: 1,
                    modDepth: 0
                };
                this.drawArtisticWave(ctx, w, h, userWave, userY, '#2a2a2a', false);
                
                // === 艺术化标签 ===
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(192, 38, 37, 0.9)';
                ctx.font = 'bold 12px Inter';
                ctx.letterSpacing = '0.15em';
                ctx.fillText('◆ TARGET SIGNAL', 20, 30);
                
                ctx.fillStyle = 'rgba(42, 42, 42, 0.9)';
                ctx.fillText('◆ YOUR SIGNAL', 20, h - 20);
                
                // === Stage indicator ===
                ctx.fillStyle = 'rgba(192, 38, 37, 0.6)';
                ctx.font = '11px Inter';
                ctx.textAlign = 'right';
                ctx.fillText(`STAGE ${this.currentStage + 1}/${this.totalStages}`, w - 20, 30);
                ctx.textAlign = 'left';
            }
            
            drawArtisticGrid(ctx, w, h) {
                // 艺术化网格 - 红色和灰色交替
                ctx.lineWidth = 0.5;
                
                const gridSize = 60;
                
                // Vertical lines
                for (let x = 0; x < w; x += gridSize) {
                    const isAccent = Math.floor(x / gridSize) % 3 === 0;
                    ctx.strokeStyle = isAccent 
                        ? 'rgba(192, 38, 37, 0.08)' 
                        : 'rgba(42, 42, 42, 0.05)';
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < h; y += gridSize) {
                    const isAccent = Math.floor(y / gridSize) % 3 === 0;
                    ctx.strokeStyle = isAccent 
                        ? 'rgba(192, 38, 37, 0.08)' 
                        : 'rgba(42, 42, 42, 0.05)';
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // Center reference line
                ctx.strokeStyle = 'rgba(192, 38, 37, 0.12)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(0, h * 0.5);
                ctx.lineTo(w, h * 0.5);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            drawArtisticWave(ctx, w, h, wave, centerY, color, isTarget) {
                const points = [];
                const resolution = 2;
                
                // Generate wave points
                for (let x = 0; x < w; x += resolution) {
                    const t = (x / w) * Math.PI * 6;
                    let y = 0;
                    
                    switch(wave.type) {
                        case 'sine':
                            y = Math.sin(t * (wave.freq * 4 + 1) + this.time);
                            break;
                            
                        case 'complex':
                            y = Math.sin(t * (wave.freq * 4 + 1) + this.time) * 0.6;
                            y += Math.sin(t * (wave.freq * 8 + 2) + this.time * 1.5) * 0.3;
                            y += Math.sin(t * (wave.freq * 16 + 4) + this.time * 0.5) * 0.1;
                            break;
                            
                        case 'modulated':
                            const carrier = Math.sin(t * (wave.freq * 4 + 1) + this.time);
                            const modulator = Math.sin(t * (wave.freq * 2) + this.time * 0.5) * wave.modDepth;
                            y = carrier * (1 + modulator);
                            break;
                            
                        case 'harmonic':
                            for (let h = 1; h <= wave.harmonics; h++) {
                                y += Math.sin(t * (wave.freq * 4 + 1) * h + this.time) / h;
                            }
                            y /= wave.harmonics;
                            break;
                    }
                    
                    // Apply amplitude
                    y *= wave.amp * h * 0.12;
                    y += centerY;
                    
                    points.push({x, y});
                }
                
                // === 艺术化线条 - 多层效果 ===
                
                // 外层光晕（柔和）
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.strokeStyle = color + '30'; // 半透明
                ctx.lineWidth = isTarget ? 6 : 7;
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                // 中层（主体线条）
                ctx.shadowBlur = 8;
                ctx.strokeStyle = color + 'CC'; // 80%不透明
                ctx.lineWidth = isTarget ? 3.5 : 4;
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                // 核心亮线
                ctx.shadowBlur = 0;
                ctx.strokeStyle = isTarget 
                    ? 'rgba(255, 255, 255, 0.9)' 
                    : 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // === 艺术化填充 ===
                const gradient = ctx.createLinearGradient(0, centerY - h * 0.1, 0, centerY + h * 0.1);
                gradient.addColorStop(0, color + '18');
                gradient.addColorStop(0.5, color + '08');
                gradient.addColorStop(1, color + '00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(w, centerY);
                ctx.closePath();
                ctx.fill();
            }
            
            updateParticles(ctx, deltaTime) {
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= deltaTime * 2;
                    return p.life > 0;
                });
                
                // Draw particles
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            cleanup() {
                console.log('🧹 Cleaning up Module 4 - Artistic Wave System...');
                this.isActive = false;
                if (this.canvas) this.canvas.style.display = 'none';
                if (this.controlDiv && this.controlDiv.parentNode) {
                    this.controlDiv.parentNode.removeChild(this.controlDiv);
                }
                this.particles = [];
                console.log('✓ Module 4 cleaned up');
            }
        }

        // ==================== MODULE 5: REFLEX ====================
        class Module5 {
            init() {
                console.log('🎯 Module 5 initializing...');
                this.canvasEl = document.getElementById('reflex-canvas');
                this.ctx = this.canvasEl.getContext('2d');
                this.canvasEl.style.display = 'block';
                this.isGameActive = true;

                this.setCanvasSize();
                this.resizeHandler = PerformanceUtils.throttle(() => this.setCanvasSize(), 250);
                window.addEventListener('resize', this.resizeHandler);

                this.dots = [];
                this.numDots = 9;
                this.targetDotIndex = -1;
                this.state = 'countdown';
                this.countdownTimer = 3; // 3秒倒计时
                this.trialCount = 0;
                this.maxTrials = 15;
                this.reactionTimes = [];
                
                this.drawInitialDots();
                this.startCountdown();

                this.onClick = this.handleClick.bind(this);
                this.canvasEl.addEventListener('mousedown', this.onClick);
                this.canvasEl.addEventListener('touchstart', this.onClick);
            }

            setCanvasSize() {
                if (!this.canvasEl) return;
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
                this.canvasEl.width = size;
                this.canvasEl.height = size;
                this.drawInitialDots();
                this.drawBackground();
            }

            drawInitialDots() {
                this.dots = [];
                const w = this.canvasEl.width;
                const h = this.canvasEl.height;
                const padding = w * 0.15;
                const gridW = (w - padding * 2) / 2;
                const gridH = (h - padding * 2) / 2;
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.dots.push({ 
                            x: padding + j * gridW, 
                            y: padding + i * gridH, 
                            r: w * 0.06, 
                            state: 'hidden',
                            index: i * 3 + j 
                        });
                    }
                }
            }

            startCountdown() {
                this.state = 'countdown';
                this.dots.forEach(d => d.state = 'hidden');
                Sound.play('reflex_start');
                
                this.countdownInterval = setInterval(() => { 
                    if (!this.isGameActive) {
                        clearInterval(this.countdownInterval);
                        return;
                    }
                    this.countdownTimer--;
                    if (this.countdownTimer <= 0) {
                        clearInterval(this.countdownInterval);
                        this.countdownInterval = null;
                        this.startTrial();
                    } else {
                        Sound.play('reflex_cue', 'C2');
                    }
                }, 1000); // 1秒间隔
            }

            startTrial() {
                if (!this.isGameActive) return;

                this.trialCount++;
                // 自由体验模式：记录试验次数但不强制完成
                if (this.trialCount > this.maxTrials) {
                    this.calculateResults();
                    // GameEngine.complete();
                    // 改为：重置试验，让用户继续体验
                    this.trialCount = 1;
                    this.reactionTimes = [];
                    // return;
                }
                
                this.state = 'wait';
                const delay = Math.random() * 2000 + 1000;
                this.cueTimeout = setTimeout(() => this.cueTarget(), delay); 
            }

            cueTarget() {
                if (!this.isGameActive) return;

                this.state = 'cue';
                this.cueTime = performance.now();
                
                const isTarget = Math.random() > 0.3;
                this.targetDotIndex = Math.floor(Math.random() * this.numDots);
                this.dots[this.targetDotIndex].state = isTarget ? 'black' : 'red';
                this.isCurrentTarget = isTarget;
                
                Sound.play('reflex_cue', 'A5');

                this.missTimeout = setTimeout(() => { 
                    if (this.isGameActive && this.state === 'cue') {
                        if (this.isCurrentTarget) {
                            this.handleMiss();
                        } else {
                            this.handleCorrectAvoid();
                        }
                    }
                }, 1000); 
            }

            handleClick(e) {
                if (this.state !== 'cue') return;

                clearTimeout(this.missTimeout);
                this.missTimeout = null;

                const rect = this.canvasEl.getBoundingClientRect();
                const clickX = (e.clientX || e.touches[0].clientX) - rect.left;
                const clickY = (e.clientY || e.touches[0].clientY) - rect.top;

                let clickedDot = null;
                this.dots.forEach(dot => {
                    const dist = Math.sqrt((clickX - dot.x)**2 + (clickY - dot.y)**2);
                    if (dist < dot.r * 1.5) clickedDot = dot;
                });
                
                if (clickedDot && clickedDot.index === this.targetDotIndex) {
                    if (this.isCurrentTarget) {
                        const reactionTime = performance.now() - this.cueTime;
                        this.reactionTimes.push(reactionTime);
                        this.handleHit(reactionTime);
                    } else {
                        this.handleWrongClick();
                    }
                } else {
                    this.handleWrongClick();
                }
            }

            handleHit(reactionTime) {
                this.state = 'click';
                this.dots[this.targetDotIndex].state = 'green';
                Sound.play('reflex_hit', 'G6');
                GameEngine.stats.score += 10;
                
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }

            handleMiss() {
                this.state = 'click';
                GameEngine.stats.errors++;
                GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 5);
                Sound.play('reflex_miss', 'C2', 0.8);
                this.dots[this.targetDotIndex].state = 'gray'; 
                
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }
            
            handleCorrectAvoid() {
                this.state = 'click';
                this.dots[this.targetDotIndex].state = 'hidden';
                GameEngine.stats.score += 5;
                setTimeout(() => this.startTrial(), 300);
            }
            
            handleWrongClick() {
                GameEngine.stats.errors++;
                GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 10);
                Sound.play('reflex_miss', 'C1', 0.5);
                
                this.state = 'click';
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }

            calculateResults() {
                const totalTime = this.reactionTimes.reduce((sum, rt) => sum + rt, 0);
                const avgTime = this.reactionTimes.length > 0 ? totalTime / this.reactionTimes.length : 500;
                GameEngine.stats.score = Math.round(avgTime);
            }

            drawBackground() {
                const ctx = this.ctx;
                const w = this.canvasEl.width;
                const h = this.canvasEl.height;

                ctx.fillStyle = '#f5f5f0'; // Match main background color
                ctx.fillRect(0, 0, w, h);
                
                this.dots.forEach(dot => {
                    if (dot.state === 'hidden') {
                        ctx.strokeStyle = 'rgba(42, 42, 42, 0.15)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, dot.r, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        let color = '#2a2a2a';
                        if (dot.state === 'black') color = '#2a2a2a';
                        if (dot.state === 'red') color = '#dd0000'; 
                        if (dot.state === 'green') color = '#00cc00'; 
                        if (dot.state === 'gray') color = '#888888';

                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, dot.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if (this.state === 'countdown') {
                    const countEl = document.getElementById('game-countdown');
                    countEl.textContent = this.countdownTimer;
                    countEl.style.opacity = 1;
                } else {
                    document.getElementById('game-countdown').style.opacity = 0;
                }
            }

            update(stats, deltaTime) {
                this.drawBackground();
            }

            cleanup() { 
                console.log('🧹 Cleaning up Module 5...');
                this.isGameActive = false;      
                
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.cueTimeout) {
                    clearTimeout(this.cueTimeout);
                    this.cueTimeout = null;
                }
                if (this.missTimeout) {
                    clearTimeout(this.missTimeout);
                    this.missTimeout = null;
                }

                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                }
                if (this.canvasEl && this.onClick) {
                    this.canvasEl.removeEventListener('mousedown', this.onClick);
                    this.canvasEl.removeEventListener('touchstart', this.onClick);
                }      
                if (this.canvasEl) {
                    this.canvasEl.style.display = 'none';
                }      
                
                // 彻底清理倒计时元素
                const countdownEl = document.getElementById('game-countdown');
                if (countdownEl) {
                    countdownEl.style.opacity = '0';
                    countdownEl.style.display = 'none';
                    countdownEl.textContent = ''; // 清空内容
                }
                
                console.log('✓ Module 5 cleaned up');
            }
        }
        
        // ==================== MODULE 6: BREATH CIRCLE - ART INSTALLATION ====================
        // 🎨 Concept: Apple Glass × Margiela Minimalism × Wabi-Sabi Zen
        // "呼吸之圆" - A meditative art piece for cognitive wellness
        
        class Module6 {
            init() {
                console.log('🌸 Module 6 - Breath Circle initializing...');
                this.group = new THREE.Group();
                this.isActive = true;
                
                // ===== 4-7-8 BREATHING PROTOCOL =====
                this.inhaleDuration = 4;
                this.holdDuration = 7;
                this.exhaleDuration = 8;
                this.cycleDuration = this.inhaleDuration + this.holdDuration + this.exhaleDuration;
                this.completedCycles = 0;
                this.totalTime = 0;
                
                // ===== WABI-SABI: BREATH TRACES =====
                this.breathTraces = []; // 禅宗记录：每次呼吸留下痕迹
                
                // ===== APPLE GLASS: FLOATING BACKGROUND LAYERS =====
                this.glassLayers = this.createGlassLayers();
                this.glassLayers.forEach(layer => this.group.add(layer));
                
                // ===== MARGIELA: THE ESSENTIAL CIRCLE =====
                this.breathCircle = this.createBreathCircle();
                this.group.add(this.breathCircle);
                
                // ===== WABI-SABI: INK PARTICLES (少量禅意墨点) =====
                this.inkParticles = this.createInkParticles();
                this.group.add(this.inkParticles);
                
                // ===== LIGHTING: SOFT AMBIENT =====
                this.group.add(new THREE.AmbientLight(0xf5f5f0, 0.8));
                const softLight = new THREE.DirectionalLight(0xffffff, 0.3);
                softLight.position.set(3, 3, 5);
                this.group.add(softLight);
                
                Visual.scene.add(this.group);
                
                // ===== UI OVERLAY: MARGIELA LABEL AESTHETIC =====
                this.createUIOverlay();
                
                // ===== SOUND: AMBIENT ATMOSPHERE =====
                this.initAmbientSound();
                
                console.log('✓ Breath Circle installation ready');
            }
            
            // ===== APPLE GLASS: 毛玻璃浮动背景 =====
            createGlassLayers() {
                const layers = [];
                const layerConfigs = [
                    { size: 18, z: -8, opacity: 0.15, speed: 0.0003, color: 0xd4d4d4 },
                    { size: 14, z: -6, opacity: 0.20, speed: 0.0005, color: 0xe0e0e0 },
                    { size: 10, z: -4, opacity: 0.25, speed: 0.0007, color: 0xebebeb }
                ];
                
                layerConfigs.forEach((config, i) => {
                    const geometry = new THREE.PlaneGeometry(config.size, config.size, 32, 32);
                    
                    // 添加细微的波浪变形（毛玻璃质感）
                    const positions = geometry.attributes.position.array;
                    for (let j = 0; j < positions.length; j += 3) {
                        positions[j + 2] = Math.sin(positions[j] * 0.5 + i) * 0.2 + 
                                          Math.cos(positions[j + 1] * 0.5 + i) * 0.2;
                    }
                    geometry.attributes.position.needsUpdate = true;
                    
                    const material = new THREE.MeshPhysicalMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: config.opacity,
                        roughness: 0.7,
                        metalness: 0.1,
                        transmission: 0.5,
                        thickness: 0.5,
                        side: THREE.DoubleSide
                    });
                    
                    const layer = new THREE.Mesh(geometry, material);
                    layer.position.z = config.z;
                    layer.userData.rotationSpeed = config.speed;
                    layer.userData.phase = i * Math.PI / 3;
                    
                    layers.push(layer);
                });
                
                return layers;
            }
            
            // ===== MARGIELA: 本质的圆形 =====
            createBreathCircle() {
                const group = new THREE.Group();
                
                // 主呼吸圆 - 不完美的侘寂美学
                const segments = 64;
                const curve = new THREE.EllipseCurve(
                    0, 0,
                    3.5, 3.5,
                    0, 2 * Math.PI,
                    false,
                    0
                );
                
                const points = curve.getPoints(segments);
                
                // 添加手绘感的不完美
                points.forEach((point, i) => {
                    const noise = (Math.sin(i * 0.5) + Math.cos(i * 0.3)) * 0.08;
                    const radius = Math.sqrt(point.x * point.x + point.y * point.y);
                    const angle = Math.atan2(point.y, point.x);
                    const newRadius = radius + noise;
                    point.x = Math.cos(angle) * newRadius;
                    point.y = Math.sin(angle) * newRadius;
                });
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x4a4a4a,
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.85
                });
                
                this.circleLine = new THREE.Line(geometry, material);
                group.add(this.circleLine);
                
                // 填充圆 - 用于呼吸动画
                const fillGeometry = new THREE.CircleGeometry(3.5, 64);
                const fillMaterial = new THREE.MeshBasicMaterial({
                    color: 0xd4d4d4,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                
                this.circleFill = new THREE.Mesh(fillGeometry, fillMaterial);
                this.circleFill.position.z = -0.1;
                group.add(this.circleFill);
                
                // 纸张纹理叠加
                const textureCanvas = document.createElement('canvas');
                textureCanvas.width = 512;
                textureCanvas.height = 512;
                const ctx = textureCanvas.getContext('2d');
                
                // 生成纸张噪声
                const imageData = ctx.createImageData(512, 512);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const noise = Math.random() * 20;
                    imageData.data[i] = 245 - noise;
                    imageData.data[i + 1] = 245 - noise;
                    imageData.data[i + 2] = 240 - noise;
                    imageData.data[i + 3] = 30;
                }
                ctx.putImageData(imageData, 0, 0);
                
                const paperTexture = new THREE.CanvasTexture(textureCanvas);
                const paperMaterial = new THREE.MeshBasicMaterial({
                    map: paperTexture,
                    transparent: true,
                    opacity: 0.3
                });
                
                const paperPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(8, 8),
                    paperMaterial
                );
                paperPlane.position.z = -0.2;
                group.add(paperPlane);
                
                return group;
            }
            
            // ===== WABI-SABI: 墨点粒子 =====
            createInkParticles() {
                const numInkDots = 150; // 极少量，禅意
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(numInkDots * 3);
                const sizes = new Float32Array(numInkDots);
                
                for (let i = 0; i < numInkDots; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 4 + Math.random() * 3;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = Math.sin(angle) * radius;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                    
                    sizes[i] = Math.random() * 0.08 + 0.04;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    color: 0x2a2a2a,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.3,
                    sizeAttenuation: true
                });
                
                return new THREE.Points(geometry, material);
            }
            
            // ===== UI OVERLAY: MARGIELA 标签美学 =====
            createUIOverlay() {
                // 移除原有文字
                const quoteEl = document.getElementById('game-intro-text');
                if (quoteEl) quoteEl.style.display = 'none';
                
                // 创建新的UI层
                this.uiContainer = document.createElement('div');
                this.uiContainer.id = 'breath-circle-ui';
                this.uiContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    font-family: 'Inter', sans-serif;
                `;
                
                // MARGIELA 标签：阶段提示
                this.phaseLabel = document.createElement('div');
                this.phaseLabel.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 255, 255, 0.95);
                    color: #2a2a2a;
                    padding: 1.5rem 3rem;
                    font-size: 0.75rem;
                    letter-spacing: 0.3em;
                    font-weight: 500;
                    text-transform: uppercase;
                    border: 1px solid #2a2a2a;
                    backdrop-filter: blur(20px);
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
                `;
                
                // 倒计时数字（超大）
                this.countdownNumber = document.createElement('div');
                this.countdownNumber.style.cssText = `
                    position: absolute;
                    top: calc(50% + 6rem);
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 5rem;
                    font-weight: 300;
                    color: rgba(42, 42, 42, 0.4);
                    font-family: 'EB Garamond', serif;
                `;
                
                // 循环计数器
                this.cycleCounter = document.createElement('div');
                this.cycleCounter.style.cssText = `
                    position: absolute;
                    top: 2rem;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 0.65rem;
                    letter-spacing: 0.2em;
                    color: rgba(42, 42, 42, 0.5);
                    font-weight: 400;
                    text-transform: uppercase;
                `;
                
                // 不添加MODULE标签 - 保持极简
                
                this.uiContainer.appendChild(this.phaseLabel);
                this.uiContainer.appendChild(this.countdownNumber);
                this.uiContainer.appendChild(this.cycleCounter);
                document.body.appendChild(this.uiContainer);
            }
            
            // ===== SOUND: 环境音景 =====
            initAmbientSound() {
                try {
                    if (typeof Tone === 'undefined') return;
                    
                    // 白噪声 + 合成器垫
                    this.ambientNoise = new Tone.Noise('pink').toDestination();
                    this.ambientNoise.volume.value = -40;
                    this.ambientNoise.start();
                    
                    // 深沉的合成器背景
                    this.ambientSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sine' },
                        envelope: {
                            attack: 3,
                            decay: 2,
                            sustain: 0.7,
                            release: 4
                        }
                    }).toDestination();
                    this.ambientSynth.volume.value = -25;
                    
                    // 风铃声（随机触发）
                    this.chimesSynth = new Tone.MetalSynth({
                        frequency: 400,
                        envelope: { attack: 0.001, decay: 0.4, release: 0.8 },
                        harmonicity: 8,
                        modulationIndex: 2,
                        resonance: 4000,
                        octaves: 1.5
                    }).toDestination();
                    this.chimesSynth.volume.value = -20;
                    
                    console.log('✓ Ambient sound initialized');
                } catch(e) {
                    console.warn('Audio initialization failed:', e);
                }
            }
            
            // ===== BREATH SOUND GUIDANCE =====
            playBreathTone(phase) {
                if (!this.ambientSynth) return;
                
                try {
                    if (phase === 'inhale') {
                        // 音高上升
                        this.ambientSynth.triggerAttackRelease(['C3', 'E3', 'G3'], '4n');
                    } else if (phase === 'hold') {
                        // 持续音
                        this.ambientSynth.triggerAttackRelease(['C4', 'E4'], '7n');
                    } else if (phase === 'exhale') {
                        // 音高下降
                        this.ambientSynth.triggerAttackRelease(['G3', 'E3', 'C3'], '8n');
                        
                        // 随机风铃（20%概率）
                        if (Math.random() < 0.2 && this.chimesSynth) {
                            setTimeout(() => {
                                this.chimesSynth.triggerAttackRelease('C5', '0.5');
                            }, Math.random() * 2000);
                        }
                    }
                } catch(e) {
                    console.warn('Sound playback error:', e);
                }
            }
            
            // ===== MAIN UPDATE LOOP =====
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                this.totalTime = stats.time;
                const elapsedInCycle = stats.time % this.cycleDuration;
                
                // ===== 确定呼吸阶段 =====
                let phase, progress, phaseText, countdown;
                
                if (elapsedInCycle < this.inhaleDuration) {
                    phase = 'inhale';
                    progress = elapsedInCycle / this.inhaleDuration;
                    countdown = Math.ceil(this.inhaleDuration - elapsedInCycle);
                    phaseText = I18N.lang === 'en' ? 'INHALE' : '吸气';
                } else if (elapsedInCycle < this.inhaleDuration + this.holdDuration) {
                    phase = 'hold';
                    progress = (elapsedInCycle - this.inhaleDuration) / this.holdDuration;
                    countdown = Math.ceil(this.inhaleDuration + this.holdDuration - elapsedInCycle);
                    phaseText = I18N.lang === 'en' ? 'HOLD' : '屏息';
                } else {
                    phase = 'exhale';
                    progress = (elapsedInCycle - this.inhaleDuration - this.holdDuration) / this.exhaleDuration;
                    countdown = Math.ceil(this.cycleDuration - elapsedInCycle);
                    phaseText = I18N.lang === 'en' ? 'EXHALE' : '呼气';
                }
                
                // 检测循环完成
                const currentCycle = Math.floor(stats.time / this.cycleDuration);
                if (currentCycle > this.completedCycles) {
                    this.completedCycles = currentCycle;
                    this.createBreathTrace(); // 禅宗记录
                    console.log(`✓ Breath cycle ${this.completedCycles} completed`);
                }
                
                // ===== 更新UI =====
                if (this.phaseLabel) {
                    this.phaseLabel.textContent = phaseText;
                    
                    // 阶段颜色变化
                    if (phase === 'inhale') {
                        this.phaseLabel.style.background = 'rgba(212, 212, 212, 0.95)';
                    } else if (phase === 'hold') {
                        this.phaseLabel.style.background = 'rgba(235, 235, 235, 0.95)';
                    } else {
                        this.phaseLabel.style.background = 'rgba(245, 245, 240, 0.95)';
                    }
                }
                
                if (this.countdownNumber) {
                    this.countdownNumber.textContent = countdown;
                }
                
                if (this.cycleCounter) {
                    this.cycleCounter.textContent = I18N.lang === 'en' 
                        ? `CYCLE ${this.completedCycles + 1}` 
                        : `第 ${this.completedCycles + 1} 次呼吸`;
                }
                
                // ===== 呼吸圆动画 =====
                if (this.circleLine && this.circleFill) {
                    let targetScale, targetOpacity, targetColor;
                    
                    if (phase === 'inhale') {
                        // 收缩：1.0 → 0.5
                        targetScale = 1.0 - progress * 0.5;
                        targetOpacity = 0.15 + progress * 0.15;
                        targetColor = new THREE.Color().lerpColors(
                            new THREE.Color(0x4a4a4a),
                            new THREE.Color(0x2a2a2a),
                            progress
                        );
                    } else if (phase === 'hold') {
                        // 轻微脉动
                        targetScale = 0.5 + Math.sin(progress * Math.PI * 6) * 0.02;
                        targetOpacity = 0.30;
                        targetColor = new THREE.Color(0x2a2a2a);
                    } else {
                        // 扩张：0.5 → 1.0
                        targetScale = 0.5 + progress * 0.5;
                        targetOpacity = 0.30 - progress * 0.15;
                        targetColor = new THREE.Color().lerpColors(
                            new THREE.Color(0x2a2a2a),
                            new THREE.Color(0x6a6a6a),
                            progress
                        );
                    }
                    
                    // 平滑插值
                    const currentScale = this.breathCircle.scale.x;
                    const newScale = currentScale + (targetScale - currentScale) * 0.1;
                    this.breathCircle.scale.set(newScale, newScale, 1);
                    
                    this.circleFill.material.opacity += (targetOpacity - this.circleFill.material.opacity) * 0.1;
                    this.circleLine.material.color.lerp(targetColor, 0.1);
                }
                
                // ===== 毛玻璃层浮动 =====
                this.glassLayers.forEach((layer, i) => {
                    layer.rotation.z += layer.userData.rotationSpeed;
                    layer.position.y = Math.sin(stats.time * 0.5 + layer.userData.phase) * 0.3;
                    layer.position.x = Math.cos(stats.time * 0.3 + layer.userData.phase) * 0.3;
                });
                
                // ===== 墨点粒子轻微漂移 =====
                if (this.inkParticles) {
                    const positions = this.inkParticles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(stats.time + i) * 0.0005;
                    }
                    this.inkParticles.geometry.attributes.position.needsUpdate = true;
                    this.inkParticles.rotation.z += 0.0002;
                }
                
                // ===== 整体旋转（极慢）=====
                this.group.rotation.y = Math.sin(stats.time * 0.05) * 0.05;
                
                // ===== 音频反馈 =====
                // 只在阶段转换时播放
                const phaseChanged = this.lastPhase !== phase;
                if (phaseChanged) {
                    this.playBreathTone(phase);
                    this.lastPhase = phase;
                }
                
                // ===== 分数计算 =====
                stats.score = this.completedCycles * 100;
            }
            
            // ===== WABI-SABI: 创建呼吸痕迹 =====
            createBreathTrace() {
                // 在背景留下淡淡的圆形水印
                const traceGeometry = new THREE.RingGeometry(3.0, 3.2, 64);
                const traceMaterial = new THREE.MeshBasicMaterial({
                    color: 0xd4d4d4,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.DoubleSide
                });
                
                const trace = new THREE.Mesh(traceGeometry, traceMaterial);
                trace.position.z = -9 - this.breathTraces.length * 0.1;
                trace.rotation.z = Math.random() * Math.PI * 2;
                
                this.breathTraces.push(trace);
                this.group.add(trace);
                
                // 限制痕迹数量（禅意留白）
                if (this.breathTraces.length > 12) {
                    const oldTrace = this.breathTraces.shift();
                    this.group.remove(oldTrace);
                    if (oldTrace.geometry) oldTrace.geometry.dispose();
                    if (oldTrace.material) oldTrace.material.dispose();
                }
            }
            
            // ===== CLEANUP =====
            cleanup() {
                console.log('🧹 Cleaning up Breath Circle...');
                this.isActive = false;
                
                // 停止环境音
                try {
                    if (this.ambientNoise) this.ambientNoise.stop();
                    if (this.ambientSynth) this.ambientSynth.releaseAll();
                    if (this.chimesSynth) this.chimesSynth.triggerRelease();
                } catch(e) {
                    console.warn('Audio cleanup warning:', e);
                }
                
                // 移除UI
                if (this.uiContainer && this.uiContainer.parentNode) {
                    this.uiContainer.parentNode.removeChild(this.uiContainer);
                }
                
                // 恢复原UI
                const quoteEl = document.getElementById('game-intro-text');
                if (quoteEl) {
                    quoteEl.style.display = '';
                    quoteEl.textContent = '';
                }
                
                // 清理3D资源
                if (Visual.scene && this.group) {
                    Visual.scene.remove(this.group);
                }
                
                const disposeMesh = (mesh) => {
                    if (mesh) {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (mesh.material.map) mesh.material.map.dispose();
                            mesh.material.dispose();
                        }
                    }
                };
                
                // 清理所有元素
                if (this.breathCircle) {
                    this.breathCircle.traverse(disposeMesh);
                }
                this.glassLayers.forEach(disposeMesh);
                disposeMesh(this.inkParticles);
                this.breathTraces.forEach(disposeMesh);
                
                console.log('✓ Breath Circle cleaned up');
                console.log(`📊 Total cycles completed: ${this.completedCycles}`);
            }
        }
        
        // ==================== UI INITIALIZATION ====================
        function initUI() {
            const cursor = document.getElementById('cursor');
            
            if (cursor) {
                // Set initial position to center of viewport
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                cursor.style.left = `${centerX}px`;
                cursor.style.top = `${centerY}px`;
                cursor.style.transform = 'translate(-50%, -50%)';
                
                // Update position on mouse move
                document.addEventListener('mousemove', e => {
                    cursor.style.left = `${e.clientX}px`;
                    cursor.style.top = `${e.clientY}px`;
                    cursor.style.transform = 'translate(-50%, -50%)';
                });
                
                document.addEventListener('mousedown', () => cursor.classList.add('active'));
                document.addEventListener('mouseup', () => cursor.classList.remove('active'));
            }
            
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    Sound.play('click');
                    I18N.set(btn.dataset.lang);
                });
            });
            
            // Initialize theme to light mode
            document.documentElement.setAttribute('data-theme', 'light');
            console.log('✓ Theme initialized: light');
            
            const welcomeScreen = document.getElementById('welcome-screen');
            const startApp = async (e) => {
                if (e.target.closest('#lang-switch')) return;
                if (!welcomeScreen.classList.contains('active')) return;

                try {
                    await Tone.start();
                    Sound.init();
                    Sound.play('click');
                } catch(err) {
                    console.warn('Audio start error:', err);
                }
                
                welcomeScreen.removeEventListener('click', startApp);
                welcomeScreen.removeEventListener('touchstart', startApp);
                
                App.setState('INFO');
            };
            
            welcomeScreen.addEventListener('click', startApp);
            welcomeScreen.addEventListener('touchstart', startApp, { passive: true });
            
            document.getElementById('info-submit').addEventListener('click', () => {
                const name = document.getElementById('user-name').value.trim();
                const age = document.getElementById('user-age').value;
                const gender = document.getElementById('user-gender').value;
                const status = document.getElementById('user-status').value;
                
                App.patient = { name, age: parseInt(age) || null, gender: gender || 'unknown', status: status || 'unknown' };
                Sound.play('click');
                App.setState('SCENT');
            });
            
            document.getElementById('scent-submit').addEventListener('click', () => {
                App.scents = { ...LumenScent.values };
                Sound.play('click');
                App.setState('MODULES');
            });
            
            document.getElementById('scent-prev').addEventListener('click', (e) => {
                e.stopPropagation();
                LumenScent.prevPage();
            });
            
            document.getElementById('scent-next').addEventListener('click', (e) => {
                e.stopPropagation();
                LumenScent.nextPage();
            });
            
            document.querySelectorAll('.page-dot').forEach(dot => {
                dot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const page = parseInt(dot.dataset.page);
                    LumenScent.goToPage(page);
                    Sound.play('click');
                });
            });
            
            const tocSlider = document.getElementById('toc-slider');
            tocSlider.addEventListener('input', (e) => {
                App.tOC = parseInt(e.target.value);
                document.getElementById('toc-value').textContent = App.tOC;
                const pitch = `C${Math.floor(App.tOC / 20) + 3}`;
                Sound.play('slider', pitch, App.tOC / 120);
            });
            
            document.getElementById('back-btn').addEventListener('click', () => {
                // 自由体验模式：保存当前进度并退出
                if (GameEngine.module && App.current) {
                    const data = {
                        time: GameEngine.stats.time || 0,
                        score: GameEngine.stats.score || 0,
                        errors: GameEngine.stats.errors || 0,
                        progress: GameEngine.stats.progress || 0
                    };
                    
                    // 保存进度
                    App.completed.add(App.current);
                    App.modules[App.current] = data;
                    
                    console.log(`✓ Module ${App.current} progress saved:`, data);
                }
                
                // 清理界面和资源
                document.getElementById('tutorial-overlay').classList.remove('active');
                
                const introTextEl = document.getElementById('game-intro-text');
                introTextEl.classList.remove('active-intro'); 
                
                ResourceManager.unregister('gamemodule');
                GameEngine.currentModuleId = null;
                GameEngine.isLoading = false;
                
                Sound.play('click');
                App.setState('MODULES');
            });
            
            document.getElementById('finish-btn').addEventListener('click', () => App.finish());
            document.getElementById('restart-btn').addEventListener('click', () => {
                // 如果已经完成过会话，跳过Profile直接到MODULES
                if (App.hasCompletedSession) {
                    App.modules = {};
                    App.completed = new Set();
                    App.current = null;
                    Sound.play('click');
                    App.setState('MODULES');
                } else {
                    // 第一次完成后第一次restart，正常流程
                    App.resetAllResources();
                    location.reload();
                }
            });
            
            document.querySelectorAll('.btn, .module-cell').forEach(el => {
                el.addEventListener('mouseenter', () => Sound.play('hover'));
            });

            I18N.set(I18N.lang);
        }
        
        // ==================== MAIN INITIALIZATION ====================
        
        // White screen detection and recovery
        let lastRenderTime = performance.now();
        let renderHealthCheckInterval = null;
        
        function checkRenderHealth() {
            const now = performance.now();
            const timeSinceLastRender = now - lastRenderTime;
            
            // If no render for 3 seconds during GAME state, something is wrong
            if (App.state === 'GAME' && timeSinceLastRender > 3000) {
                console.error('⚠️ Render freeze detected! Attempting recovery...');
                try {
                    // 只清理资源，不自动退出
                    ResourceManager.unregister('gamemodule');
                    GameEngine.module = null;
                    GameEngine.isLoading = false;
                    
                    // Try to restore Visual system
                    if (Visual.scene && Visual.camera && Visual.renderer) {
                        Visual.setScene('GAME');  // 保持在GAME状态
                    }
                    
                    // 不自动跳转 - 让用户决定
                    alert('Render freeze detected. Please use "SAVE & EXIT" button if needed.');
                    // App.setState('MODULES');  // 移除自动跳转
                } catch(recoveryErr) {
                    console.error('Recovery failed:', recoveryErr);
                    alert('Critical error. Please use "SAVE & EXIT" button or refresh the page.');
                }
            }
            
            lastRenderTime = now;
        }
        
        // Start health monitoring
        function startHealthMonitoring() {
            if (renderHealthCheckInterval) {
                clearInterval(renderHealthCheckInterval);
            }
            renderHealthCheckInterval = setInterval(checkRenderHealth, 2000);
        }
        
        window.addEventListener('load', () => { 
            try {
                // Global error handlers
                window.addEventListener('error', (e) => {
                    console.error('❌ Global error:', e.error);
                    try {
                        // 只记录错误，不自动退出
                        if (App.state === 'GAME') {
                            console.warn('Error in GAME state. User can manually exit if needed.');
                            // 不自动跳转，让用户决定
                            // ResourceManager.unregister('gamemodule');
                            // setTimeout(() => {
                            //     try {
                            //         App.setState('MODULES');
                            //     } catch(err) {
                            //         console.error('State recovery failed:', err);
                            //     }
                            // }, 100);
                        }
                    } catch(recoveryErr) {
                        console.error('Error recovery failed:', recoveryErr);
                    }
                    e.preventDefault();
                });
                
                window.addEventListener('unhandledrejection', (e) => {
                    console.error('❌ Unhandled promise rejection:', e.reason);
                    try {
                        // 只记录错误，不自动退出
                        if (App.state === 'GAME' && e.reason && e.reason.message) {
                            console.warn('Promise rejection in GAME state. User can manually exit if needed.');
                            // 不自动跳转
                            // ResourceManager.unregister('gamemodule');
                            // setTimeout(() => App.setState('MODULES'), 100);
                        }
                    } catch(recoveryErr) {
                        console.error('Promise error recovery failed:', recoveryErr);
                    }
                    e.preventDefault();
                });
                
                // Initialize Visual system
                const visualInit = Visual.init();
                if (!visualInit) {
                    throw new Error('Visual system failed to initialize');
                }
                
                // Initialize UI
                initUI();
                
                // Start health monitoring
                startHealthMonitoring();
                
                console.log('🌸 NeuroScent Core Fixed Edition loaded');
                console.log('✅ ResourceManager active');
                console.log('✅ Enhanced error recovery system');
                console.log('✅ White screen detection enabled');
                console.log('✅ Render health monitoring active');
            } catch(e) {
                console.error('❌ Critical initialization error:', e);
                alert('Application failed to initialize. Please refresh the page.');
            }
        });
        
        window.addEventListener('beforeunload', (e) => {
            // Cleanup health monitoring
            if (renderHealthCheckInterval) {
                clearInterval(renderHealthCheckInterval);
            }
            
            // Warn if user has unsaved progress
            if (App.completed.size > 0 && App.state !== 'RESULTS') {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    });
    </script>
</body>
</html>
